(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.rainCore = {}));
})(this, (function (exports) { 'use strict';

    /* reactive 响应式标识 */
    const IS_REACTIVE = '__isReactive';
    /* reactive 响应式标识 */

    const IS_REF = '__isRef';
    /* 代理前对象标识 */

    const RAW = '__raw';
    /* 判断是否是对象 */

    function isObject(target) {
      return typeof target === 'object' && target != null;
    }
    /* 判断是否是数组 */

    function isArray$1(target) {
      return Array.isArray(target);
    }
    /* 判断是否是函数 */

    function isFunction(target) {
      return typeof target === 'function' && target != null;
    }
    /* 判断是否是 reactive 响应式对象 */

    function isReactive(target) {
      return !!(target && target[IS_REACTIVE]);
    }
    /* 判断是否是 ref 响应式对象 */

    function isRef(value) {
      return !!(value && value[IS_REF]);
    }
    /* 判断两个值是否一致 */

    function hasChanged(oldValue, newValue) {
      return oldValue !== newValue && !(Number.isNaN(oldValue) || Number.isNaN(newValue));
    }

    const effectStack = [];
    /* 暴露依赖 */

    let activeEffect;

    function effect(func) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      const effectFn = () => {
        try {
          effectStack.push(effectFn);
          activeEffect = effectFn;
          return func();
        } finally {
          effectStack.pop();
          activeEffect = effectStack[effectStack.length - 1];
        }
      };
      /* 是否先执行一次 */


      if (!options.lazy) effectFn();
      effectFn.scheduler = options.scheduler;
      return effectFn;
    }
    /* 收集依赖 */


    const targetMap = new WeakMap();

    function track(target, key) {
      /* 是否有依赖需要收集 没有直接发返回 */
      if (!activeEffect) return;
      /* 
          查找是否有此响应式数据对应的依赖组 
          如果没有为该数据创建 Map 
      */

      let depsMap = targetMap.get(target);
      if (!depsMap) targetMap.set(target, depsMap = new Map());
      /* 
          查找是否有此响应式数据内数据的依赖组 
          如果没有为该数据创建 Set 
      */

      let deps = depsMap.get(key);
      if (!deps) depsMap.set(key, deps = new Set());
      /* 把用到此数据的依赖挂载到 effectFn 上 提供删除 */

      activeEffect.deps = deps;
      /* 添加依赖 */

      deps.add(activeEffect);
    }
    /* 触发依赖 */


    function trigger(target, key, value) {
      const depsMap = targetMap.get(target);
      /* 
          查找是否有此响应式数据对应的依赖组 
          没有就直接返回
      */

      if (!depsMap) return;
      /* 
         查找是否有此响应式数据内数据的依赖组 
         没有就直接返回
      */

      const deps = depsMap.get(key);
      if (!deps) return;
      /* 触发依赖 */

      deps.forEach(effect => {
        /* 有调度 scheduler 优先触发 scheduler */
        effect.scheduler ? effect.scheduler(effect, value) : effect();
      });
    }

    /* 保存响应式对象 */

    const reactiveMap = new WeakMap();

    function reactive(target) {
      /* 如果不是对象直接返回 */
      if (!isObject(target)) return target;
      /* 是否已经是响应式对象 如果是直接返回 */

      if (isReactive(target)) return target;
      /* 如果对象已经做过响应式 就直接返沪响应式对象 */

      if (reactiveMap.has(target)) return reactiveMap.get(target);
      /* 创建响应式对象 */

      return createReactiveObject(target);
    }
    /* 提供一个响应式对象，返回原始对象 */


    function toRaw(target) {
      if (isReactive(target)) return target[RAW];
    }

    function createReactiveObject(target) {
      const raw = target;
      const proxy = new Proxy(target, {
        get(target, key, receiver) {
          /* 判断是否是响应式对象 */
          if (key === IS_REACTIVE) return true;
          /* 获取原对象 */

          if (key === RAW) return raw;
          const result = Reflect.get(target, key, receiver);
          /* 收集依赖 */

          track(target, key);
          /* 返回值 */

          return isObject(result) ? reactive(result) : result;
        },

        set(target, key, value, receiver) {
          /* 获取旧值 */
          const oldValue = target[key];
          const oldLength = target.length;
          const result = Reflect.set(target, key, value, receiver);
          /* 判断新值和旧值是否不一样 */

          if (hasChanged(oldValue, value)) {
            /* 触发依赖 */
            trigger(target, key, value);
            /* 如果是数组 判断是否依赖长度 是 判断是否改变 改变触发依赖 */

            if (isArray$1(target) && target.length !== oldLength) trigger(target, 'length');
          }

          return result;
        }

      });
      /* 添加记录 */

      reactiveMap.set(target, proxy);
      return proxy;
    }

    function ref(value) {
      /* 是否已经是响应式对象 如果是直接返回 */
      if (isRef(value)) return value;
      /* 创建响应式对象 */

      return new refImpl(value);
    }

    class refImpl {
      /* 
          都是基础类型  __rawValue 和 _value 相等
          如果是对象 
              __rawValue：原始对象
              _value：响应式对象
      */
      constructor(value) {
        this.__isRef = true;
        this.__rawValue = value;
        this._value = convert(value);
      }

      get value() {
        /* 收集依赖 */
        track(this, 'value');
        /* 返回值 */

        return this._value;
      }

      set value(value) {
        if (hasChanged(this._value, value)) {
          /* 更新数据 */
          this._value = convert(value);
          this.__rawValue = value;
          /* 触发依赖 */

          trigger(this, 'value', value);
        }
      }

    }

    function convert(value) {
      return isObject(value) ? reactive(value) : value;
    }
    /* 自动判断是否是 ref 并且获取值 不是 旧返回参数 */


    function unRef(ref) {
      return isRef(ref) ? ref.value : ref;
    }

    /* 返回一个函数 调用 停止监听 */

    function watchEffect(func) {
      let effectFn = effect(func);
      const deps = effectFn.deps;
      return function () {
        deps.delete(effectFn);
        effectFn = null;
      };
    }

    function watch(getter, func) {
      let _value = isRef(getter) ? getter.value : getter();

      let effectFn = effect(() => isRef(getter) ? getter.value : getter(), {
        scheduler: (effect, value) => {
          func(value, _value);
          _value = value;
        }
      });
      const deps = effectFn.deps;
      return function () {
        deps.delete(effectFn);
        effectFn = null;
        _value = null;
      };
    }

    function computed(getterOrOptions) {
      let getter, setter;

      if (isFunction(getterOrOptions)) {
        getter = getterOrOptions;

        setter = () => {
          console.warn('Write operation failed: computed value is readonly');
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }

      return new ComputedRefImpl(getter, setter);
    }

    class ComputedRefImpl {
      constructor(getter, setter) {
        this._setter = setter;
        /* 缓存结果 */

        this._value = undefined;
        /* 判断依赖值是否改变 */

        this._dirty = true;
        /* 监听依赖变化 */

        this.effect = effect(getter, {
          lazy: true,
          scheduler: () => {
            if (!this._dirty) {
              this._dirty = true;
              /* 触发依赖 */

              trigger(this, 'value', this._value);
            }
          }
        });
      }

      get value() {
        if (this._dirty) {
          this._value = this.effect();
          this._dirty = false;
          /* 收集依赖 */

          track(this, 'value');
        }

        return this._value;
      }

      set value(value) {
        this._setter(value);
      }

    }

    /* vNode 类型 */

    /* vNode 类型判断 使用位运算 可以提高效率 */
    const ShapeFlags = {
      ELEMENT: 1,
      // 00000001 元素
      TEXT: 1 << 1,
      // 00000010 文本
      FRAGMENT: 1 << 2,
      // 00000100 容器
      COMPONENT: 1 << 3,
      // 00001000 组件
      TEXT_CHILDREN: 1 << 4,
      // 00010000 string 孩子
      ARRAY_CHILDREN: 1 << 5,
      // 00100000 数组 孩子
      CHILDREN: 1 << 4 | 1 << 5 //00110000 孩子

    };
    /* 文本唯一标识 */

    const Text = Symbol('Text');
    /* 容器唯一标识 */

    const Fragment = Symbol('Fragment');
    /* 判断是否是字符串 */

    function isString(target) {
      return typeof target === 'string';
    }
    /* 判断是否是字符串 */

    function isNumber(target) {
      return typeof target === 'number';
    }
    /* 判断是否是字符串 */

    function isArray(target) {
      return Array.isArray(target);
    }
    /* 判断是否是同类型的vNode */

    function isSameVNode(n1, n2) {
      return n1.type === n2.type;
    }
    /* 判断孩子是否都有key */

    function isChildrenKey(c1, c2) {
      let c1True = 0,
          c2True = 0;
      c1.forEach(c => {
        if (c && c['key'] != null) c1True++;
      });
      c2.forEach(c => {
        if (c && c['key'] != null) c2True++;
      });
      return c1True === c1.length && c2True === c2.length;
    }
    /* 判断 vNode 类型 */

    function vNodeType(type) {
      /* 判断是否是标签 */
      if (isString(type)) return ShapeFlags.ELEMENT;
      /* 判断是否是文本 */

      if (type === Text) return ShapeFlags.TEXT;
      /* 是否是容器 */

      if (type === Fragment) return ShapeFlags.FRAGMENT;
      /* 是否是组件 */

      return ShapeFlags.COMPONENT;
    }
    /* dom 属性正则 */

    const domPropsRE = /[A-Z]|^(value|checked|selected|muted|disabled)$/;

    function h(type, props, children) {
      let shapeFlag = vNodeType(type);
      /* 判断 孩子 是否是 字符串 或者 数字 */

      if (isString(children) || isNumber(children)) {
        /* 用位或运算整合 */
        shapeFlag |= ShapeFlags.TEXT_CHILDREN;
        children = children.toString();
      }
      /* 判断 孩子 是否是 数组 */


      if (isArray(children)) {
        /* 用位或运算整合 */
        shapeFlag |= ShapeFlags.ARRAY_CHILDREN;
      }

      return {
        type,
        props,
        children,
        shapeFlag,
        elm: null,
        anchor: null
      };
    }

    /* 挂载元素 */

    function mountElement(vNode, container, anchor) {
      const {
        type,
        props,
        shapeFlag,
        children
      } = vNode;
      const el = document.createElement(type);
      if (props) patchProps(null, props, el);
      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) el.textContent = vNode.children;
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) mountChildren(children, el);
      vNode.elm = el;
      container.insertBefore(el, anchor);
    }
    /* 挂载文本 */


    function mountTextNode(vNode, container, anchor) {
      const textNode = document.createTextNode(vNode.children);
      vNode.elm = textNode;
      container.insertBefore(textNode, anchor);
    }
    /* 挂载孩子 */


    function mountChildren(children, container, anchor) {
      children.forEach(child => {
        patch(null, child, container, anchor);
      });
    }

    /* 处理容器 */


    function processFragment(n1, n2, container, anchor) {
      const fragmentStartAnchor = n2.elm = n1 ? n1.elm : document.createTextNode('');
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : document.createTextNode('');

      if (n1) {
        patchChildren(n1, n2, container, fragmentEndAnchor);
      } else {
        container.insertBefore(fragmentStartAnchor, anchor);
        container.insertBefore(fragmentEndAnchor, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor);
      }
    }
    /* 处理文本 */


    function processText(n1, n2, container, anchor) {
      if (n1) {
        if (n1.elm?.textContent !== n2.children) n1.elm.textContent = n2.children;
        n2.elm = n1.elm;
      } else {
        mountTextNode(n2, container, anchor);
      }
    }
    /* 处理元素 */


    function processElement(n1, n2, container, anchor) {
      if (n1) {
        patchElement(n1, n2);
      } else {
        mountElement(n2, container, anchor);
      }
    }

    /* 卸载 vNode */

    function unmount(vNode) {
      const {
        shapeFlag
      } = vNode;

      if (shapeFlag & ShapeFlags.COMPONENT) ; else if (shapeFlag & ShapeFlags.FRAGMENT) {
        unmountFragment(vNode);
      } else {
        unmountElementOrText(vNode);
      }
    } // TODO 卸载组件
    /* 卸载容器 */


    function unmountFragment(vNode) {
      let {
        elm: cur,
        anchor: end
      } = vNode;
      const parentNode = cur.parentNode;

      while (cur !== end) {
        const next = cur.nextSibling;
        parentNode.removeChild(cur);
        cur = next;
      }

      parentNode.removeChild(end);
    }
    /* 卸载元素或文本 */


    function unmountElementOrText(vNode) {
      const {
        elm
      } = vNode;
      elm.parentNode.removeChild(elm);
    }
    /* 卸载孩子 */


    function unmountChildren(children) {
      children.forEach(child => {
        unmount(child);
      });
    }

    function patch(n1, n2, container, anchor) {
      if (n1 && !isSameVNode(n1, n2)) {
        /* n1被卸载后，n2将会创建，因此anchor至关重要。需要将它设置为n1的下一个兄弟节点 */
        anchor = (n1.anchor || n1.elm).nextSibling;
        unmount(n1);
        n1 = null;
      }

      const {
        shapeFlag
      } = n2;
      /* 判断 n2 是否是文本 */

      if (shapeFlag & ShapeFlags.TEXT) processText(n1, n2, container, anchor);
      /* 判断 n2 是否是元素 */

      if (shapeFlag & ShapeFlags.FRAGMENT) processFragment(n1, n2, container, anchor);
      /* 判断 n2 是否是容器 */

      if (shapeFlag & ShapeFlags.ELEMENT) processElement(n1, n2, container, anchor);
    }
    /* 更新元素 */


    function patchElement(n1, n2) {
      n2.elm = n1.elm;
      patchProps(n1.props, n2.props, n2.elm);
      patchChildren(n1, n2, n2.elm);
    }
    /* 更新属性 */


    function patchProps(oldProps, newProps, container) {
      if (oldProps === newProps) return;
      oldProps = oldProps || {};
      newProps = newProps || {};

      for (const key in newProps) {
        if (key === 'key') continue;
        const prev = oldProps[key];
        const next = newProps[key];

        if (prev !== next) {
          patchDomProp(container, key, prev, next);
        }
      }

      for (const key in oldProps) {
        if (key !== 'key' && !(key in newProps)) {
          patchDomProp(container, key, oldProps[key], null);
        }
      }
    }
    /* 更新 DOM 属性 */


    function patchDomProp(el, key, prev, next) {
      switch (key) {
        case 'class':
          // 暂时认为class就是字符串
          // next可能为null，会变成'null'，因此要设成''
          el.className = next || '';
          break;

        case 'style':
          // style为对象
          if (!next) {
            el.removeAttribute('style');
          } else {
            for (const styleName in next) {
              el.style[styleName] = next[styleName];
            }

            if (prev) {
              for (const styleName in prev) {
                if (next[styleName] == null) {
                  el.style[styleName] = '';
                }
              }
            }
          }

          break;

        default:
          if (/^on[^a-z]/.test(key)) {
            // 事件
            if (prev !== next) {
              const eventName = key.slice(2).toLowerCase();

              if (prev) {
                el.removeEventListener(eventName, prev);
              }

              if (next) {
                el.addEventListener(eventName, next);
              }
            }
          } else if (domPropsRE.test(key)) {
            if (next === '' && typeof el[key] === 'boolean') {
              next = true;
            }

            el[key] = next;
          } else {
            // 例如自定义属性{custom: ''}，应该用setAttribute设置为<input custom />
            // 而{custom: null}，应用removeAttribute设置为<input />
            if (next == null || next === false) {
              el.removeAttribute(key);
            } else {
              el.setAttribute(key, next);
            }
          }

          break;
      }
    }
    /* 更新孩子 */


    function patchChildren(n1, n2, container, anchor) {
      const {
        shapeFlag: prevShapeFlag,
        children: c1
      } = n1;
      const {
        shapeFlag,
        children: c2
      } = n2;
      /* 新 vNode 孩子是 文本 */

      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
        /* 旧 vNode 孩子是 数组  卸载孩子*/
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1);
        /* 如果 新旧孩子文本内容不一致 文本内容设置为 新孩子    PS：旧 vNode 孩子是 数组 testContent 是 null */

        if (c2 !== c1) container.textContent = c2;
        /* 新 vNode 孩子是 数组 */
      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        /* 旧 vNode 孩子是 数组*/
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          /* 判断是否有key 调用不同的 diff 算法 */
          if (isChildrenKey(c1, c2)) ; else {
            patchUnKeyedChildren(c1, c2, container, anchor);
          }
        } else {
          /* 旧 vNode 孩子是 文本 或 null */
          container.textContent = null;
          mountChildren(c2, container, anchor);
        }
        /* 新 vNode 孩子是 null */

      } else {
        /* 旧 vNode 孩子是 文本 */
        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) container.textContent = null;
        /* 旧 vNode 孩子是 数组 */

        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1);
      }
    }

    function patchUnKeyedChildren(c1, c2, container, anchor) {
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);

      for (let i = 0; i < commonLength; i++) {
        patch(c1[i], c2[i], container, anchor);
      }

      if (newLength > oldLength) {
        mountChildren(c2.slice(commonLength), container, anchor);
      } else if (newLength < oldLength) {
        unmountChildren(c1.slice(commonLength));
      }
    }

    /* 渲染函数 */

    function render(vNode, container) {
      const pervVNode = container._vNode;
      /*  判断是否传入新的vNode */

      if (vNode) {
        /* 进行 diff 算法 */
        patch(pervVNode, vNode, container);
      } else {
        /* 没有传入新的 vNode 且有旧的 vNode 卸载旧 vNode */
        if (pervVNode) unmount(pervVNode);
      }

      container._vNode = vNode;
    }

    exports.Fragment = Fragment;
    exports.Text = Text;
    exports.computed = computed;
    exports.h = h;
    exports.isReactive = isReactive;
    exports.isRef = isRef;
    exports.reactive = reactive;
    exports.ref = ref;
    exports.render = render;
    exports.toRaw = toRaw;
    exports.unRef = unRef;
    exports.watch = watch;
    exports.watchEffect = watchEffect;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=rainCore.min.js.map
