(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.rainCore = {}));
})(this, (function (exports) { 'use strict';

    /* reactive 响应式标识 */
    const IS_REACTIVE = '__isReactive';
    /* reactive 响应式标识 */

    const IS_REF = '__isRef';
    /* 代理前对象标识 */

    const RAW = '__raw';
    /* 判断是否是对象 */

    function isObject$1(target) {
      return typeof target === 'object' && target != null;
    }
    /* 判断是否是数组 */

    function isArray$1(target) {
      return Array.isArray(target);
    }
    /* 判断是否是函数 */

    function isFunction(target) {
      return typeof target === 'function' && target != null;
    }
    /* 判断是否是 reactive 响应式对象 */

    function isReactive(target) {
      return !!(target && target[IS_REACTIVE]);
    }
    /* 判断是否是 ref 响应式对象 */

    function isRef(value) {
      return !!(value && value[IS_REF]);
    }
    /* 判断两个值是否一致 */

    function hasChanged(oldValue, newValue) {
      return oldValue !== newValue && !(Number.isNaN(oldValue) || Number.isNaN(newValue));
    }

    const effectStack = [];
    /* 暴露依赖 */

    let activeEffect;

    function effect(func) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      const effectFn = () => {
        try {
          effectStack.push(effectFn);
          activeEffect = effectFn;
          return func();
        } finally {
          effectStack.pop();
          activeEffect = effectStack[effectStack.length - 1];
        }
      };
      /* 是否先执行一次 */


      if (!options.lazy) effectFn();
      effectFn.scheduler = options.scheduler;
      return effectFn;
    }
    /* 收集依赖 */


    const targetMap = new WeakMap();

    function track(target, key) {
      /* 是否有依赖需要收集 没有直接发返回 */
      if (!activeEffect) return;
      /* 
          查找是否有此响应式数据对应的依赖组 
          如果没有为该数据创建 Map 
      */

      let depsMap = targetMap.get(target);
      if (!depsMap) targetMap.set(target, depsMap = new Map());
      /* 
          查找是否有此响应式数据内数据的依赖组 
          如果没有为该数据创建 Set 
      */

      let deps = depsMap.get(key);
      if (!deps) depsMap.set(key, deps = new Set());
      /* 把用到此数据的依赖挂载到 effectFn 上 提供删除 */

      activeEffect.deps = deps;
      /* 添加依赖 */

      deps.add(activeEffect);
    }
    /* 触发依赖 */


    function trigger(target, key, value) {
      const depsMap = targetMap.get(target);
      /* 
          查找是否有此响应式数据对应的依赖组 
          没有就直接返回
      */

      if (!depsMap) return;
      /* 
         查找是否有此响应式数据内数据的依赖组 
         没有就直接返回
      */

      const deps = depsMap.get(key);
      if (!deps) return;
      /* 触发依赖 */

      deps.forEach(effect => {
        /* 有调度 scheduler 优先触发 scheduler */
        effect.scheduler ? effect.scheduler(effect, value) : effect();
      });
    }

    /* 保存响应式对象 */

    const reactiveMap = new WeakMap();

    function reactive(target) {
      /* 如果不是对象直接返回 */
      if (!isObject$1(target)) return target;
      /* 是否已经是响应式对象 如果是直接返回 */

      if (isReactive(target)) return target;
      /* 如果对象已经做过响应式 就直接返沪响应式对象 */

      if (reactiveMap.has(target)) return reactiveMap.get(target);
      /* 创建响应式对象 */

      return createReactiveObject(target);
    }
    /* 提供一个响应式对象，返回原始对象 */


    function toRaw(target) {
      if (isReactive(target)) return target[RAW];
    }

    function createReactiveObject(target) {
      const raw = target;
      const proxy = new Proxy(target, {
        get(target, key, receiver) {
          /* 判断是否是响应式对象 */
          if (key === IS_REACTIVE) return true;
          /* 获取原对象 */

          if (key === RAW) return raw;
          const result = Reflect.get(target, key, receiver);
          /* 收集依赖 */

          track(target, key);
          /* 返回值 */

          return isObject$1(result) ? reactive(result) : result;
        },

        set(target, key, value, receiver) {
          /* 获取旧值 */
          const oldValue = target[key];
          const oldLength = target.length;
          const result = Reflect.set(target, key, value, receiver);
          /* 判断新值和旧值是否不一样 */

          if (hasChanged(oldValue, value)) {
            /* 触发依赖 */
            trigger(target, key, value);
            /* 如果是数组 判断是否依赖长度 是 判断是否改变 改变触发依赖 */

            if (isArray$1(target) && target.length !== oldLength) trigger(target, 'length');
          }

          return result;
        }

      });
      /* 添加记录 */

      reactiveMap.set(target, proxy);
      return proxy;
    }

    function ref(value) {
      /* 是否已经是响应式对象 如果是直接返回 */
      if (isRef(value)) return value;
      /* 创建响应式对象 */

      return new refImpl(value);
    }

    class refImpl {
      /* 
          都是基础类型  __rawValue 和 _value 相等
          如果是对象 
              __rawValue：原始对象
              _value：响应式对象
      */
      constructor(value) {
        this.__isRef = true;
        this.__rawValue = value;
        this._value = convert(value);
      }

      get value() {
        /* 收集依赖 */
        track(this, 'value');
        /* 返回值 */

        return this._value;
      }

      set value(value) {
        if (hasChanged(this._value, value)) {
          /* 更新数据 */
          this._value = convert(value);
          this.__rawValue = value;
          /* 触发依赖 */

          trigger(this, 'value', value);
        }
      }

    }

    function convert(value) {
      return isObject$1(value) ? reactive(value) : value;
    }
    /* 自动判断是否是 ref 并且获取值 不是 旧返回参数 */


    function unRef(ref) {
      return isRef(ref) ? ref.value : ref;
    }

    /* 返回一个函数 调用 停止监听 */

    function watchEffect(func) {
      let effectFn = effect(func);
      const deps = effectFn.deps;
      return function () {
        deps.delete(effectFn);
        effectFn = null;
      };
    }

    function watch(getter, func) {
      let _value = isRef(getter) ? getter.value : getter();

      let effectFn = effect(() => isRef(getter) ? getter.value : getter(), {
        scheduler: (effect, value) => {
          func(value, _value);
          _value = value;
        }
      });
      const deps = effectFn.deps;
      return function () {
        deps.delete(effectFn);
        effectFn = null;
        _value = null;
      };
    }

    function computed(getterOrOptions) {
      let getter, setter;

      if (isFunction(getterOrOptions)) {
        getter = getterOrOptions;

        setter = () => {
          console.warn('Write operation failed: computed value is readonly');
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }

      return new ComputedRefImpl(getter, setter);
    }

    class ComputedRefImpl {
      constructor(getter, setter) {
        this._setter = setter;
        /* 缓存结果 */

        this._value = undefined;
        /* 判断依赖值是否改变 */

        this._dirty = true;
        /* 监听依赖变化 */

        this.effect = effect(getter, {
          lazy: true,
          scheduler: () => {
            if (!this._dirty) {
              this._dirty = true;
              /* 触发依赖 */

              trigger(this, 'value', this._value);
            }
          }
        });
      }

      get value() {
        if (this._dirty) {
          this._value = this.effect();
          this._dirty = false;
          /* 收集依赖 */

          track(this, 'value');
        }

        return this._value;
      }

      set value(value) {
        this._setter(value);
      }

    }

    /* vNode 类型 */

    /* 组件实例类型 */

    /* vNode 类型判断 使用位运算 可以提高效率 */
    const ShapeFlags = {
      ELEMENT: 1,
      // 00000001 元素
      TEXT: 1 << 1,
      // 00000010 文本
      FRAGMENT: 1 << 2,
      // 00000100 容器
      COMPONENT: 1 << 3,
      // 00001000 组件
      TEXT_CHILDREN: 1 << 4,
      // 00010000 string 孩子
      ARRAY_CHILDREN: 1 << 5,
      // 00100000 数组 孩子
      CHILDREN: 1 << 4 | 1 << 5 //00110000 孩子

    };
    /* 文本唯一标识 */

    const Text = Symbol('Text');
    /* 容器唯一标识 */

    const Fragment = Symbol('Fragment');
    /* 判断是否是字符串 */

    function isString(target) {
      return typeof target === 'string';
    }
    /* 判断是否是字符串 */

    function isNumber(target) {
      return typeof target === 'number';
    }
    /* 判断是否是对象 */

    function isObject(target) {
      return typeof target === 'object' && target != null;
    }
    /* 判断是否是字符串 */

    function isArray(target) {
      return Array.isArray(target);
    }
    /* 判断是否是同类型的vNode */

    function isSameVNode(n1, n2) {
      return n1.type === n2.type;
    }
    /* 判断孩子是否都有key */

    function isChildrenKey(c1, c2) {
      let c1True = 0,
          c2True = 0;
      c1.forEach(c => {
        if (c && c['key'] != null) c1True++;
      });
      c2.forEach(c => {
        if (c && c['key'] != null) c2True++;
      });
      return c1True === c1.length && c2True === c2.length;
    }
    /* 判断 vNode 类型 */

    function vNodeType(type) {
      /* 判断是否是标签 */
      if (isString(type)) return ShapeFlags.ELEMENT;
      /* 判断是否是文本 */

      if (type === Text) return ShapeFlags.TEXT;
      /* 是否是容器 */

      if (type === Fragment) return ShapeFlags.FRAGMENT;
      /* 是否是组件 */

      return ShapeFlags.COMPONENT;
    }
    /* dom 属性正则 */

    const domPropsRE = /[A-Z]|^(value|checked|selected|muted|disabled)$/;
    /* 最长上升子序列算法 */

    function getSequence(numberArray) {
      const result = [];
      const position = [];

      for (let i = 0; i < numberArray.length; i++) {
        if (numberArray[i] === -1) {
          continue;
        } // result[result.length - 1]可能为undefined，此时numberArray[i] > undefined为false


        if (numberArray[i] > result[result.length - 1]) {
          result.push(numberArray[i]);
          position.push(result.length - 1);
        } else {
          let l = 0,
              r = result.length - 1;

          while (l <= r) {
            const mid = ~~((l + r) / 2);

            if (numberArray[i] > result[mid]) {
              l = mid + 1;
            } else if (numberArray[i] < result[mid]) {
              r = mid - 1;
            } else {
              l = mid;
              break;
            }
          }

          result[l] = numberArray[i];
          position.push(l);
        }
      }

      let cur = result.length - 1;

      for (let i = position.length - 1; i >= 0 && cur >= 0; i--) {
        if (position[i] === cur) {
          result[cur--] = i;
        }
      }

      return result;
    }

    function h(type, props, children) {
      let shapeFlag = vNodeType(type);
      /* 判断 孩子 是否是 字符串 或者 数字 */

      if (isString(children) || isNumber(children)) {
        /* 用位或运算整合 */
        shapeFlag |= ShapeFlags.TEXT_CHILDREN;
        children = children.toString();
      }
      /* 判断 孩子 是否是 数组 */


      if (isArray(children)) {
        /* 用位或运算整合 */
        shapeFlag |= ShapeFlags.ARRAY_CHILDREN;
      }

      return {
        type,
        props,
        children,
        shapeFlag,
        elm: null,
        anchor: null,
        key: props && props.key,
        component: null
      };
    }
    /* render 返回值 二次处理 */


    function normalizeVNode(result) {
      /* 数组 用 Fragment 包起来 */
      if (Array.isArray(result)) {
        return h(Fragment, null, result);
      }
      /* 对象 直接返回 */


      if (isObject(result)) {
        return result;
      }
      /* 字符串 或 数组 文Text 包起来 */


      return h(Text, null, result.toString());
    }

    /* 初始化 Props 不接的 当成 attrs属性 处理 */

    function initProps(instance, vNode) {
      const {
        type: Component,
        props: vNodeProps
      } = vNode;
      const props = instance.props = {};
      const attrs = instance.attrs = {};

      for (const key in vNodeProps) {
        if (Component.props?.includes(key)) {
          props[key] = vNodeProps[key];
        } else {
          attrs[key] = vNodeProps[key];
        }
      }
      /* props 设置成 响应式 */


      instance.props = reactive(instance.props);
    }

    function fallThrough(instance, subTree) {
      if (Object.keys(instance.attrs).length) {
        subTree.props = { ...subTree.props,
          ...instance.attrs
        };
      }
    }

    function updateComponent(n1, n2) {
      n2.component = n1.component;
      n2.component.next = n2;
      n2.component.update();
    }

    /* 更新队列 */
    const queue = [];
    /* 是否正在更新 */

    let isFlushing = false;
    /* 使用微任务更新 */

    const resolePromise = Promise.resolve();
    /* 给队列添加事件 */

    function queueJob(job) {
      if (!queue.length || !queue.includes(job)) {
        queue.push(job);
        queueFlushJob();
      }
    }
    /* 在微任务中执行事件 */


    function queueFlushJob() {
      if (!isFlushing) {
        isFlushing = true;
        resolePromise.then(flushJobs);
      }
    }

    function flushJobs() {
      try {
        for (let i = 0; i < queue.length; i++) {
          queue[i]();
        }
      } finally {
        queue.length = 0;
        isFlushing = false;
      }
    }

    /* 挂载元素 */

    function mountElement(vNode, container, anchor) {
      const {
        type,
        props,
        shapeFlag,
        children
      } = vNode;
      const el = document.createElement(type);
      if (props) patchProps(null, props, el);
      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) el.textContent = vNode.children;
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) mountChildren(children, el);
      vNode.elm = el;
      container.insertBefore(el, anchor);
    }
    /* 挂载文本 */


    function mountTextNode(vNode, container, anchor) {
      const textNode = document.createTextNode(vNode.children);
      vNode.elm = textNode;
      container.insertBefore(textNode, anchor);
    }
    /* 挂载孩子 */


    function mountChildren(children, container, anchor) {
      children.forEach(child => {
        patch(null, child, container, anchor);
      });
    }
    /* 挂载组件 */


    function mountComponent(vNode, container, anchor) {
      const {
        type: Component
      } = vNode;
      /* 实例模板 */

      const instance = vNode.component = {
        props: {},
        attrs: {},
        setupState: null,
        ctx: null,
        update: null,
        isMounted: false,
        subTree: null,
        next: null
      };
      /* 初始化 Props */

      initProps(instance, vNode);
      /* 运行 setup */

      instance.setupState = Component.setup?.(instance.props, {
        attrs: instance.attrs
      });
      /* 设置 ctx */

      instance.ctx = { ...instance.props,
        ...instance.setupState
      };
      /* 设置渲染函数 */

      instance.update = effect(() => {
        /* 判断是否未挂载 */
        if (!instance.isMounted) {
          const subTree = instance.subTree = normalizeVNode(Component.render(instance.ctx));
          /* 设置 subTree 的 props 属性 */

          fallThrough(instance, subTree);
          /* 挂载组件 */

          patch(null, subTree, container, anchor);
          instance.isMounted = true;
          vNode.elm = subTree.elm;
        } else {
          // instance.next存在，代表是被动更新。否则是主动更新
          if (instance.next) {
            vNode = instance.next;
            instance.next = null;
            initProps(instance, vNode);
            instance.ctx = { ...instance.props,
              ...instance.setupState
            };
          }
          /* 获取上一次 render 返回的 vNode */


          const prev = instance.subTree;
          const subTree = instance.subTree = normalizeVNode(Component.render(instance.ctx));
          /* 设置 subTree 的 props 属性 */

          fallThrough(instance, subTree);
          /* 对比 两次 render 返回的 vNode*/

          patch(prev, subTree, container, anchor);
          vNode.elm = subTree.elm;
        }
      }, {
        scheduler: queueJob
      });
    }

    /* 处理组件 */

    function processComponent(n1, n2, container, anchor) {
      if (n1) {
        updateComponent(n1, n2);
      } else {
        mountComponent(n2, container, anchor);
      }
    }
    /* 处理容器 */


    function processFragment(n1, n2, container, anchor) {
      const fragmentStartAnchor = n2.elm = n1 ? n1.elm : document.createTextNode('');
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : document.createTextNode('');

      if (n1) {
        patchChildren(n1, n2, container, fragmentEndAnchor);
      } else {
        container.insertBefore(fragmentStartAnchor, anchor);
        container.insertBefore(fragmentEndAnchor, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor);
      }
    }
    /* 处理文本 */


    function processText(n1, n2, container, anchor) {
      if (n1) {
        if (n1.elm?.textContent !== n2.children) n1.elm.textContent = n2.children;
        n2.elm = n1.elm;
      } else {
        mountTextNode(n2, container, anchor);
      }
    }
    /* 处理元素 */


    function processElement(n1, n2, container, anchor) {
      if (n1) {
        patchElement(n1, n2);
      } else {
        mountElement(n2, container, anchor);
      }
    }

    /* 卸载 vNode */

    function unmount(vNode) {
      const {
        shapeFlag
      } = vNode;

      if (shapeFlag & ShapeFlags.COMPONENT) {
        unmountComponent(vNode);
      } else if (shapeFlag & ShapeFlags.FRAGMENT) {
        unmountFragment(vNode);
      } else {
        unmountElementOrText(vNode);
      }
    }
    /* 卸载组件 */


    function unmountComponent(vNode) {
      unmount(vNode.component.subTree);
    }
    /* 卸载容器 */


    function unmountFragment(vNode) {
      let {
        elm: cur,
        anchor: end
      } = vNode;
      const parentNode = cur.parentNode;

      while (cur !== end) {
        const next = cur.nextSibling;
        parentNode.removeChild(cur);
        cur = next;
      }

      parentNode.removeChild(end);
    }
    /* 卸载元素或文本 */


    function unmountElementOrText(vNode) {
      const {
        elm
      } = vNode;
      elm.parentNode.removeChild(elm);
    }
    /* 卸载孩子 */


    function unmountChildren(children) {
      children.forEach(child => {
        unmount(child);
      });
    }

    function patch(n1, n2, container, anchor) {
      if (n1 && !isSameVNode(n1, n2)) {
        /* n1被卸载后，n2将会创建，因此anchor至关重要。需要将它设置为n1的下一个兄弟节点 */
        anchor = (n1.anchor || n1.elm).nextSibling;
        unmount(n1);
        n1 = null;
      }

      const {
        shapeFlag
      } = n2;
      /* 判断 n2 是否是组件 */

      if (shapeFlag & ShapeFlags.COMPONENT) processComponent(n1, n2, container, anchor);
      /* 判断 n2 是否是文本 */

      if (shapeFlag & ShapeFlags.TEXT) processText(n1, n2, container, anchor);
      /* 判断 n2 是否是元素 */

      if (shapeFlag & ShapeFlags.FRAGMENT) processFragment(n1, n2, container, anchor);
      /* 判断 n2 是否是容器 */

      if (shapeFlag & ShapeFlags.ELEMENT) processElement(n1, n2, container, anchor);
    }
    /* 更新元素 */


    function patchElement(n1, n2) {
      n2.elm = n1.elm;
      patchProps(n1.props, n2.props, n2.elm);
      patchChildren(n1, n2, n2.elm);
    }
    /* 更新属性 */


    function patchProps(oldProps, newProps, container) {
      if (oldProps === newProps) return;
      oldProps = oldProps || {};
      newProps = newProps || {};

      for (const key in newProps) {
        if (key === 'key') continue;
        const prev = oldProps[key];
        const next = newProps[key];

        if (prev !== next) {
          patchDomProp(container, key, prev, next);
        }
      }

      for (const key in oldProps) {
        if (key !== 'key' && !(key in newProps)) {
          patchDomProp(container, key, oldProps[key], null);
        }
      }
    }
    /* 更新 DOM 属性 */


    function patchDomProp(el, key, prev, next) {
      switch (key) {
        case 'class':
          // 暂时认为class就是字符串
          // next可能为null，会变成'null'，因此要设成''
          el.className = next || '';
          break;

        case 'style':
          // style为对象
          if (!next) {
            el.removeAttribute('style');
          } else {
            for (const styleName in next) {
              el.style[styleName] = next[styleName];
            }

            if (prev) {
              for (const styleName in prev) {
                if (next[styleName] == null) {
                  el.style[styleName] = '';
                }
              }
            }
          }

          break;

        default:
          if (/^on[^a-z]/.test(key)) {
            // 事件
            if (prev !== next) {
              const eventName = key.slice(2).toLowerCase();

              if (prev) {
                el.removeEventListener(eventName, prev);
              }

              if (next) {
                el.addEventListener(eventName, next);
              }
            }
          } else if (domPropsRE.test(key)) {
            if (next === '' && typeof el[key] === 'boolean') {
              next = true;
            }

            el[key] = next;
          } else {
            // 例如自定义属性{custom: ''}，应该用setAttribute设置为<input custom />
            // 而{custom: null}，应用removeAttribute设置为<input />
            if (next == null || next === false) {
              el.removeAttribute(key);
            } else {
              el.setAttribute(key, next);
            }
          }

          break;
      }
    }
    /* 更新孩子 */


    function patchChildren(n1, n2, container, anchor) {
      const {
        shapeFlag: prevShapeFlag,
        children: c1
      } = n1;
      const {
        shapeFlag,
        children: c2
      } = n2;
      /* 新 vNode 孩子是 文本 */

      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
        /* 旧 vNode 孩子是 数组  卸载孩子*/
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1);
        /* 如果 新旧孩子文本内容不一致 文本内容设置为 新孩子    PS：旧 vNode 孩子是 数组 testContent 是 null */

        if (c2 !== c1) container.textContent = c2;
        /* 新 vNode 孩子是 数组 */
      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        /* 旧 vNode 孩子是 数组*/
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          /* 判断是否有key 调用不同的 diff 算法 */
          if (isChildrenKey(c1, c2)) {
            /* 有 key 时 */
            patchKeyedChildren(c1, c2, container, anchor);
          } else {
            /* 无 key 时 */
            patchUnKeyedChildren(c1, c2, container, anchor);
          }
        } else {
          /* 旧 vNode 孩子是 文本 或 null */
          container.textContent = null;
          mountChildren(c2, container, anchor);
        }
        /* 新 vNode 孩子是 null */

      } else {
        /* 旧 vNode 孩子是 文本 */
        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) container.textContent = null;
        /* 旧 vNode 孩子是 数组 */

        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1);
      }
    }
    /* 有 key 时 使用的 diff 算法 */


    function patchKeyedChildren(c1, c2, container, anchor) {
      let start = 0,
          e1 = c1.length - 1,
          e2 = c2.length - 1;
      /* 1. 从左向右对比 */

      while (start <= e1 && start <= e2 && c1[start].key === c2[start].key) {
        patch(c1[start], c2[start], container, anchor);
        start++;
      }
      /* 2. 从右向左对比 */


      while (start <= e1 && start <= e2 && c1[e1].key === c2[e2].key) {
        patch(c1[e1], c2[e2], container, anchor);
        e1--;
        e2--;
      }
      /* 3.1 比对后 旧孩子 已无元素 */


      if (start > e1) {
        const nextPos = e2 + 1;
        const curAnchor = c2[nextPos] && c2[nextPos].elm || anchor;

        for (let i = start; i <= e2; i++) {
          patch(null, c2[i], container, curAnchor);
        }
      }
      /* 3.2 对比后 新孩子 已无元素 */


      if (start > e2) {
        for (let i = start; i <= e1; i++) {
          unmount(c1[i]);
        }
      }
      /* 4. 对比后 新旧孩子 都还有元素 采用传统diff算法，但不真的添加和移动，只做标记和删除 */


      if (start <= e1 && start <= e2) {
        /* 记录旧孩子 查询使用 */
        const map = new Map();

        for (let i = start; i <= e1; i++) {
          map.set(c1[i].key, {
            prev: c1[i],
            index: i
          });
        }
        /* 旧孩子中上一个对比元素位置下标 */


        let maxNewIndexSoFar = 0;
        /* 是否移动 开关 */

        let move = false;
        /* 旧孩子中没有没有新孩子节点的下标 给未开启 move 使用 */

        const toMounted = [];
        /* 初始化 sources 下标 数组 */

        const sources = new Array(e2 - start + 1).fill(-1);
        /* 查找新节点在旧节点的位置 并且 做标记 和 删除 map 中找到的元素 */

        for (let i = 0; i < e2 - start + 1; i++) {
          const nextPos = c2[i + start];
          /* 判断 旧孩子 中是否有 新孩子的key */

          if (map.has(nextPos.key)) {
            const {
              prev,
              index
            } = map.get(nextPos.key);
            /* 进行对比 */

            patch(prev, nextPos, container, anchor);
            /* 判断 当前位置是否需要移动  */

            if (index < maxNewIndexSoFar) {
              move = true;
            } else {
              maxNewIndexSoFar = index;
            }
            /* 设置 新旧孩子节点 下标对应关系 */


            sources[i] = index;
            /* 删除 map 中对应的 key 值 */

            map.delete(nextPos.key);
          } else {
            /* 旧孩子中未找到新孩子节点的下标存入 toMounted */
            toMounted.push(i + start);
          }
        }
        /* 删除 旧孩子 剩余元素 */


        map.forEach(_ref => {
          let {
            prev
          } = _ref;
          unmount(prev);
        });
        /* 5. 移动开关开启时 移动元素操作 采用新的最长上升子序列算法 */

        if (move) {
          /* 最长上升子序列 下标数组 */
          const sequence = getSequence(sources);
          /* 数组最长下标 */

          let length = sequence.length - 1;

          for (let i = sources.length - 1; i >= 0; i--) {
            /* 下标符合 不做移动 */
            if (i === sequence[length]) {
              length--;
            } else {
              const pos = i + start;
              const nextPos = pos + 1;
              const curAnchor = c2[nextPos] && c2[nextPos].elm || anchor;

              if (sources[i] === -1) {
                /* 旧孩子没有此节点 进行挂载 */
                patch(null, c2[pos], container, curAnchor);
              } else {
                /* 移动操作 */
                container.insertBefore(c2[pos].elm, curAnchor);
              }
            }
          }
          /* 6. 未开启 move 还有元素需要添加 情况 */

        } else if (toMounted.length) {
          for (let i = toMounted.length - 1; i >= 0; i++) {
            const pos = toMounted[i];
            const nextPos = pos + 1;
            const curAnchor = c2[nextPos] && c2[nextPos].elm || anchor;
            patch(null, c2[pos], container, curAnchor);
          }
        }
      }
    }
    /* 无 key 时 使用的 diff 算法 */


    function patchUnKeyedChildren(c1, c2, container, anchor) {
      const oldLength = c1.length;
      const newLength = c2.length;
      /* 选取最短的子数组 */

      const commonLength = Math.min(oldLength, newLength);
      /* 对比共同长度的子节点 */

      for (let i = 0; i < commonLength; i++) {
        patch(c1[i], c2[i], container, anchor);
      }
      /* 新孩子 多于 旧孩子 剩下部分 挂载孩子 */


      if (newLength > oldLength) mountChildren(c2.slice(commonLength), container, anchor);
      /* 旧孩子 多于 新孩子 剩下部分 卸载孩子 */

      if (newLength < oldLength) unmountChildren(c1.slice(commonLength));
    }

    /* 渲染函数 */

    function render(vNode, container) {
      const pervVNode = container._vNode;
      /*  判断是否传入新的vNode */

      if (vNode) {
        /* 进行 diff 算法 */
        patch(pervVNode, vNode, container);
      } else {
        /* 没有传入新的 vNode 且有旧的 vNode 卸载旧 vNode */
        if (pervVNode) unmount(pervVNode);
      }

      container._vNode = vNode;
    }

    function renderList(source, renderItem) {
      const nodes = [];
      /* 传入值为 数字 */

      if (isNumber(source)) {
        for (let i = 0; i < source; i++) {
          nodes.push(renderItem(i + 1, i));
        }

        return nodes;
      }
      /* 传入值为 数组 或 字符串 */


      if (isArray(source) || isString(source)) {
        for (let i = 0; i < source.length; i++) {
          nodes.push(renderItem(source[i], i));
        }

        return nodes;
      }
      /* 传入值为 对象 */


      if (isObject(source)) {
        const keys = Object.keys(source);
        keys.forEach((key, index) => {
          nodes.push(renderItem(source[key], key, index));
        });
        return nodes;
      }

      return nodes;
    }

    /* HTML 标准元素 */
    const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot';
    /* HTML 标准自闭合元素 */

    const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
    /* 提供字符串生成判断函数 */

    function makeMap(str) {
      const map = str.split(',').reduce((map, item) => (map[item] = true, map), Object.create(null));
      return value => !!map[value];
    }
    /* HTML 标准元素 判断函数 */


    const isNativeTag = makeMap(HTML_TAGS);
    /* HTML 标准自闭合元素 判断函数 */

    const isVoidTag = makeMap(VOID_TAGS);
    /* 删除指定长度内容 */

    function advanceBy(context, numberOfCharacters) {
      const {
        source
      } = context;
      context.source = source.slice(numberOfCharacters);
    }
    /* 删除空格 */

    function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      match && advanceBy(context, match[0].length);
    }
    /* 判断是否解析完成 */

    function isEnd(context) {
      const template = context.source;
      return !template || template.startsWith('</');
    }
    /* 截取文本数据返回 并删除模板内对应数据 */

    function textData(context, length) {
      const text = context.source.slice(0, length);
      advanceBy(context, length);
      return text;
    }
    /* my-class 变 驼峰 myClass */

    function camelize(str) {
      return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : '');
    }

    /* 节点类型 */

    var NodeTypes;
    /* 元素类型 */

    (function (NodeTypes) {
      NodeTypes["ROOT"] = "ROOT";
      NodeTypes["ELEMENT"] = "ELEMENT";
      NodeTypes["TEXT"] = "TEXT";
      NodeTypes["SIMPLE_EXPRESSION"] = "SIMPLE_EXPRESSION";
      NodeTypes["INTERPOLATION"] = "INTERPOLATION";
      NodeTypes["ATTRIBUTE"] = "ATTRIBUTE";
      NodeTypes["DIRECTIVE"] = "DIRECTIVE";
    })(NodeTypes || (NodeTypes = {}));

    var ElementTypes;
    /* 模板上下文 类型 */

    (function (ElementTypes) {
      ElementTypes["ELEMENT"] = "ELEMENT";
      ElementTypes["COMPONENT"] = "COMPONENT";
    })(ElementTypes || (ElementTypes = {}));

    /* 创建解析模板上下文 */
    function createParserContext(template) {
      return {
        options: {
          delimiters: ['{{', '}}'],
          isNativeTag,
          isVoidTag
        },
        source: template
      };
    }
    /* 创建 root 节点 */


    function createRoot(children) {
      return {
        type: NodeTypes.ROOT,
        children
      };
    }

    /* 模板解析器 */

    function parse(template) {
      const context = createParserContext(template);
      return createRoot(parseChildren(context));
    }
    /* 解析孩子 */


    function parseChildren(context) {
      const nodes = [];

      while (!isEnd(context)) {
        const template = context.source;
        let node;
        /* 开头是否是 插值标识符 */

        if (template.startsWith(context.options.delimiters[0])) {
          node = parseInterpolation(context);
          /* 开头是否是 < */
        } else if (template.startsWith('<')) {
          node = parseElement(context);
          /* 文本节点 */
        } else {
          node = parseText(context);
        }

        nodes.push(node);
      }
      /* 优化 空格 和 换行 */

      /* 是否删除文本节点开关 */


      let removedWhitespace = false;

      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        /* 判断是否是文本节点 */

        if (node.type === NodeTypes.TEXT) {
          /* 判断是否此文本节点为空 */
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1];
            const next = nodes[i + 1];
            /* 前一个节点为空 或 后一个节点为空 或 前后都是元素节点且本节点有换行符 则删除本节点 否则 压缩空格 */

            if (!prev || !next || prev.type === NodeTypes.ELEMENT && next.type === NodeTypes.ELEMENT && /[\r\n]/.test(node.content)) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = ' ';
            }
          } else {
            /* 不为空 压缩空格 */
            node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
          }
        }
      }

      return removedWhitespace ? nodes.filter(Boolean) : nodes;
    }
    /* 解析插值语法 */


    function parseInterpolation(context) {
      /* 拿出插值标识符 */
      const [open, close] = context.options.delimiters;
      /* 删除左插值符 */

      advanceBy(context, open.length);
      /* 取出内容并删除模板内对应数据 */

      const closeIndex = context.source.indexOf(close);
      const content = textData(context, closeIndex).trim();
      /* 删除右插值符 */

      advanceBy(context, close.length);
      return {
        type: NodeTypes.INTERPOLATION,
        content: {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content,
          isStatic: false
        }
      };
    }
    /* 解析元素 */


    function parseElement(context) {
      /* 解析元素 */
      const element = parseTag(context);
      /* 如果是自闭合标签 直接返回 */

      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) return element;
      /* 解析孩子 */

      element.children = parseChildren(context);
      /* 解析结束标签 但是不做收集 */

      parseTag(context);
      return element;
    }
    /* 解析元素标签 */


    function parseTag(context) {
      const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      /* 读取元素标签 */

      const tag = match[1];
      /* 删除 标签 接下来的空格 */

      advanceBy(context, match[0].length);
      advanceSpaces(context);
      /* 获取标签类型 原生 还是 组件 */

      const tagType = context.options.isNativeTag(tag) ? ElementTypes.ELEMENT : ElementTypes.COMPONENT;
      /* 解析 属性 和 指令 */

      const {
        props,
        directives
      } = parseAttributes(context);
      /* 判断是否是自闭合标签 */

      const isSelfClosing = context.source.startsWith('/>');
      /* 删除结束 > 或者 /> */

      advanceBy(context, isSelfClosing ? 2 : 1);
      return {
        type: NodeTypes.ELEMENT,
        tag,
        tagType,
        props,
        directives,
        isSelfClosing,
        children: []
      };
    }
    /* 解析元素标签属性 */


    function parseAttributes(context) {
      const props = [],
            directives = [];
      /* 解析 属性 合 指令 */

      while (context.source.length && !context.source.startsWith('>') && !context.source.startsWith('/>')) {
        let attr = parseAttribute(context);
        attr.type === NodeTypes.DIRECTIVE ? directives.push(attr) : props.push(attr);
      }

      return {
        props,
        directives
      };
    }
    /* 解析单个属性 */


    function parseAttribute(context) {
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      /* 获取 属性 活 指令 名 */

      const name = match[0];
      advanceBy(context, name.length);
      advanceSpaces(context);
      /* 获取 属性 或 指令 对应的值 */

      let content;

      if (context.source[0] === '=') {
        advanceBy(context, 1);
        advanceSpaces(context);
        content = parseAttributeValue(context);
        advanceSpaces(context);
      }
      /* 是否是 指令 */


      if (/^(r-|@|:)/.test(name)) {
        let dirName, argContent;

        if (name[0] === ':') {
          dirName = 'bind';
          argContent = name.slice(1);
        }

        if (name[0] === '@') {
          dirName = 'on';
          argContent = name.slice(1);
        }

        if (name.startsWith('r-')) {
          [dirName, argContent] = name.slice(2).split(':');
        }
        /* 返回 指令 */


        return {
          type: NodeTypes.DIRECTIVE,
          name: dirName,
          arg: argContent && {
            type: NodeTypes.SIMPLE_EXPRESSION,
            content: camelize(argContent),
            isStatic: true
          },
          exp: content && {
            type: NodeTypes.SIMPLE_EXPRESSION,
            content: content,
            isStatic: false
          }
        };
      }
      /* 返回 属性 */


      return {
        type: NodeTypes.ATTRIBUTE,
        name,
        value: content && {
          type: NodeTypes.TEXT,
          content: content
        }
      };
    }
    /* 解析单个属性对应的值 */


    function parseAttributeValue(context) {
      /* 获取是 单引号 还是 双引号 */
      const quote = context.source[0];
      advanceBy(context, 1);
      const endIndex = context.source.indexOf(quote);
      /* 获取内容 */

      const content = textData(context, endIndex);
      advanceBy(context, 1);
      return content;
    }
    /* 解析文本 */


    function parseText(context) {
      const {
        delimiters
      } = context.options;
      /* < < > 判断正则 */

      const lessRegexp = /\<[^\<\>]+(\<[^\<\>]+\>)/;
      /* 插值 {{ {{ }} 判断正则 */

      const interpolation = new RegExp(`${delimiters[0]}[^${delimiters[0]}${delimiters[1]}]+(${delimiters[0]}[^${delimiters[0]}${delimiters[1]}]+${delimiters[1]})`);
      /* 结束长度 */

      let endIndex = context.source.length;
      /* 
          判断 文本节点中是否带 < 
          如果有 就找最先满足 < > 的位置
          没有 就直接找最先的 < 
      */

      /* 对比是否小于 结束长度 并替换 */

      if (lessRegexp.test(context.source)) {
        const index = context.source.indexOf(lessRegexp.exec(context.source)[1]);
        if (index !== -1 && endIndex > index) endIndex = index;
      } else {
        const index = context.source.indexOf('<');
        if (index !== -1 && endIndex > index) endIndex = index;
      }
      /* 
          判断 文本节点中是否带 左插值 
          如果有 就找最先满足 完整插值 的位置 
          没有 就直接找最先的 左插值 
      */

      /* 对比是否小于 结束长度 并替换 */


      if (interpolation.test(context.source)) {
        const index = context.source.indexOf(interpolation.exec(context.source)[1]);
        if (index !== -1 && endIndex > index) endIndex = index;
      } else {
        const index = context.source.indexOf(delimiters[0]);
        if (index !== -1 && endIndex > index) endIndex = index;
      }

      const content = textData(context, endIndex);
      return {
        type: NodeTypes.TEXT,
        content
      };
    }

    /* 首字母大写 */
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }

    /* 解析 普通指令 */

    function createDirectives(directives, node) {
      const resultDirectives = directives.map(directive => {
        switch (directive.name) {
          case 'bind':
            return `${directive.arg.content}: ${createText(directive.exp)}`;

          case 'on':
            let exp = directive.exp.content;
            let result = directive.exp.content;
            /* 支持 加减乘除 简单运算表达式 */

            if (/(\+|\-|\*|\/)/.test(exp) && !exp.includes('=>') && !exp.includes('function')) result = `$event => (${exp})`;
            /* 支持传递参数版本 */

            if (/\([^\)]*?\)$/.test(exp)) if (!/^(\$event)/.test(result)) result = `$event => (${exp})`;
            return `on${capitalize(directive.arg.content)}: ${result}`;

          default:
            return `${directive.name}: ${createText(directive.exp)}`;
        }
      });
      return resultDirectives;
    }
    /* 解析 特殊指令 */

    /* 解析 if else-if else */


    function directiveIf(ifNode, node, parent) {
      const {
        exp
      } = ifNode;
      /* if */

      const consequent = resolveElementASTNode(node, parent);
      /* else */

      let alternate;
      const {
        children
      } = parent;
      /* 寻找 else-if else */

      let index = children.findIndex(child => child === node) + 1;

      for (let i = index; i < children.length; i++) {
        /* 获取当前 node */
        const sibling = children[i];
        /* 删除 空白 文本节点 */

        if (sibling.type === NodeTypes.TEXT && !sibling.content.trim()) {
          children.splice(i, 1);
          i--;
          continue;
        }
        /* 解析 else-if else */


        if (sibling.type === NodeTypes.ELEMENT && (pluck(sibling.directives, 'else') || pluck(sibling.directives, 'else-if', false))) {
          alternate = resolveElementASTNode(sibling, parent);
          children.splice(i, 1);
        }

        break;
      }

      return `${exp.content} ? ${consequent} : ${alternate || createTextVNode()}`;
    }
    /* 解析 for */


    function directiveFor(forNode, node) {
      const {
        exp
      } = forNode;
      /* 允许 in of */

      const [args, source] = exp.content.split(/\sin\s|\sof\s/);
      return `h(Fragment, null, renderList(${source.trim()}, ${args.trim()} => ${resolveElementASTNode(node)}))`;
    }
    /* 解析 model */


    function directiveModel(modelNode, node) {
      node.directives.push({
        type: NodeTypes.DIRECTIVE,
        name: 'bind',
        exp: modelNode.exp,
        arg: {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: 'value',
          isStatic: true
        }
      }, {
        type: NodeTypes.DIRECTIVE,
        name: 'on',
        exp: {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: `($event) => ${modelNode.exp.content} = $event.target.value`,
          isStatic: false
        },
        arg: {
          type: NodeTypes.SIMPLE_EXPRESSION,
          content: 'input',
          isStatic: true
        }
      });
    }
    /* 查找特殊指令 并 返回 且 决定是否 删除 */


    function pluck(directives, name) {
      let remove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      const index = directives.findIndex(directive => directive.name === name);
      const directive = directives[index];
      if (index > -1 && remove) directives.splice(index, 1);
      return directive;
    }

    /* 生成 render 渲染函数 */

    function generate(ast) {
      return `
    const { h, Text, Fragment, renderList, resolveComponent } = rainCore
        with(ctx) {
            return ${traverseNode(ast)}
        }
   `;
    }
    /* 解析 ast 和 指令 生成 渲染函数 */


    function traverseNode(node, parent) {
      switch (node.type) {
        case NodeTypes.ROOT:
          return createChildrenVNode(node);

        case NodeTypes.ELEMENT:
          return resolveElementASTNode(node, parent);

        case NodeTypes.INTERPOLATION:
          return createInterpolationVNode(node);

        case NodeTypes.TEXT:
          return createTextVNode(node);
      }
    }
    /* 处理 特殊指令 */


    function resolveElementASTNode(node, parent) {
      /* 解析 if else-if else */
      const ifNode = pluck(node.directives, 'if') || pluck(node.directives, 'else-if');
      if (ifNode) return directiveIf(ifNode, node, parent);
      /* 解析 model */

      const modelNode = pluck(node.directives, 'model');
      if (modelNode) directiveModel(modelNode, node);
      /* 解析 for */

      const forNode = pluck(node.directives, 'for');
      if (forNode) return directiveFor(forNode, node);
      return createElementVNode(node);
    }
    /* 生成元素节点 渲染函数 */


    function createElementVNode(node) {
      /* 获取标签名 */
      const tag = node.tagType === ElementTypes.ELEMENT ? `"${node.tag}"` : `resolveComponent("${node.tag}")`;
      /* 解析属性和指令 */

      const propsArr = createPropsArr(node);
      const props = propsArr.length ? `{ ${propsArr.join(', ')} }` : null;
      /* 解析孩子 */

      const children = node.children.length ? createChildrenVNode(node) : null;
      return `h(${tag}, ${props}, ${children})`;
    }
    /* 解析 属性 和 指令 */


    function createPropsArr(node) {
      const {
        props,
        directives
      } = node;
      return [
      /* 解析 属性 */
      ...props.map(prop => `${prop.name}: ${createText(prop.value)}`),
      /* 解析指令 */
      ...createDirectives(directives)];
    }
    /* 生成孩子节点 渲染函数 */


    function createChildrenVNode(node) {
      const {
        children
      } = node;
      const result = [];

      for (let i = 0; i < children.length; i++) {
        result.push(traverseNode(children[i], node));
      }

      return `[${result.join(', ')}]`;
    }
    /* 生成插值节点 渲染函数 */


    function createInterpolationVNode(node) {
      return `h(Text, null, ${createText(node.content)})`;
    }
    /* 生成文本节点 渲染函数 */


    function createTextVNode(node) {
      return `h(Text, null, ${createText(node)})`;
    }
    /* 生成 静态文本 还是 表达式 */


    function createText() {
      let {
        isStatic = true,
        content = ''
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return isStatic ? JSON.stringify(content) : content;
    }

    /* 解析 模板 并 转换成 render 渲染函数 */

    function compile(template) {
      const ast = parse(template);
      return generate(ast);
    }

    let components;

    function createApp(component) {
      /* 注册组件 */
      components = component.components || {};
      /* 不写渲染函数形式 且 有模板 */

      if (!component.render && component.template) {
        if (component.template[0] === '#') {
          const el = document.querySelector(component.template);
          el ? component.template = el.innerHTML : '';
        }

        component.render = new Function('ctx', compile(component.template));
      }

      return {
        mount(container) {
          /* 获取挂载点 */
          if (isString(container)) container = document.querySelector(container);
          /* 不写渲染函数形式 且 不写模板 */

          if (!component.render && !component.template) {
            component.template = container.innerHTML;
            component.render = new Function('ctx', compile(component.template));
            container.innerHTML = '';
          }

          render(h(component, null, null), container);
        }

      };
    }

    function resolveComponent(name) {
      let component;
      /* 傻逼浏览器乱弄大小写 */

      Object.keys(components).findIndex(key => {
        if (key.toLowerCase() === name.toLowerCase()) component = components[key];
      });

      if (!component.render && component.template) {
        if (component.template[0] === '#') {
          const el = document.querySelector(component.template);
          el ? component.template = el.innerHTML : '';
        }

        component.render = new Function('ctx', compile(component.template));
      }

      return component;
    }

    exports.Fragment = Fragment;
    exports.Text = Text;
    exports.compile = compile;
    exports.computed = computed;
    exports.createApp = createApp;
    exports.h = h;
    exports.isReactive = isReactive;
    exports.isRef = isRef;
    exports.parse = parse;
    exports.reactive = reactive;
    exports.ref = ref;
    exports.render = render;
    exports.renderList = renderList;
    exports.resolveComponent = resolveComponent;
    exports.toRaw = toRaw;
    exports.unRef = unRef;
    exports.watch = watch;
    exports.watchEffect = watchEffect;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=rainCore.min.js.map
