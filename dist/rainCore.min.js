(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.rainCore = {}));
})(this, (function (exports) { 'use strict';

    /* reactive 响应式标识 */
    const IS_REACTIVE = '__isReactive';
    /* reactive 响应式标识 */

    const IS_REF = '__isRef';
    /* 代理前对象标识 */

    const RAW = '__raw';
    /* 判断是否是对象 */

    function isObject$1(target) {
      return typeof target === 'object' && target != null;
    }
    /* 判断是否是数组 */

    function isArray$1(target) {
      return Array.isArray(target);
    }
    /* 判断是否是函数 */

    function isFunction(target) {
      return typeof target === 'function' && target != null;
    }
    /* 判断是否是 reactive 响应式对象 */

    function isReactive(target) {
      return !!(target && target[IS_REACTIVE]);
    }
    /* 判断是否是 ref 响应式对象 */

    function isRef(value) {
      return !!(value && value[IS_REF]);
    }
    /* 判断两个值是否一致 */

    function hasChanged(oldValue, newValue) {
      return oldValue !== newValue && !(Number.isNaN(oldValue) || Number.isNaN(newValue));
    }

    const effectStack = [];
    /* 暴露依赖 */

    let activeEffect;

    function effect(func) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      const effectFn = () => {
        try {
          effectStack.push(effectFn);
          activeEffect = effectFn;
          return func();
        } finally {
          effectStack.pop();
          activeEffect = effectStack[effectStack.length - 1];
        }
      };
      /* 是否先执行一次 */


      if (!options.lazy) effectFn();
      effectFn.scheduler = options.scheduler;
      return effectFn;
    }
    /* 收集依赖 */


    const targetMap = new WeakMap();

    function track(target, key) {
      /* 是否有依赖需要收集 没有直接发返回 */
      if (!activeEffect) return;
      /* 
          查找是否有此响应式数据对应的依赖组 
          如果没有为该数据创建 Map 
      */

      let depsMap = targetMap.get(target);
      if (!depsMap) targetMap.set(target, depsMap = new Map());
      /* 
          查找是否有此响应式数据内数据的依赖组 
          如果没有为该数据创建 Set 
      */

      let deps = depsMap.get(key);
      if (!deps) depsMap.set(key, deps = new Set());
      /* 把用到此数据的依赖挂载到 effectFn 上 提供删除 */

      activeEffect.deps = deps;
      /* 添加依赖 */

      deps.add(activeEffect);
    }
    /* 触发依赖 */


    function trigger(target, key, value) {
      const depsMap = targetMap.get(target);
      /* 
          查找是否有此响应式数据对应的依赖组 
          没有就直接返回
      */

      if (!depsMap) return;
      /* 
         查找是否有此响应式数据内数据的依赖组 
         没有就直接返回
      */

      const deps = depsMap.get(key);
      if (!deps) return;
      /* 触发依赖 */

      deps.forEach(effect => {
        /* 有调度 scheduler 优先触发 scheduler */
        effect.scheduler ? effect.scheduler(effect, value) : effect();
      });
    }

    /* 保存响应式对象 */

    const reactiveMap = new WeakMap();

    function reactive(target) {
      /* 如果不是对象直接返回 */
      if (!isObject$1(target)) return target;
      /* 是否已经是响应式对象 如果是直接返回 */

      if (isReactive(target)) return target;
      /* 如果对象已经做过响应式 就直接返沪响应式对象 */

      if (reactiveMap.has(target)) return reactiveMap.get(target);
      /* 创建响应式对象 */

      return createReactiveObject(target);
    }
    /* 提供一个响应式对象，返回原始对象 */


    function toRaw(target) {
      if (isReactive(target)) return target[RAW];
    }

    function createReactiveObject(target) {
      const raw = target;
      const proxy = new Proxy(target, {
        get(target, key, receiver) {
          /* 判断是否是响应式对象 */
          if (key === IS_REACTIVE) return true;
          /* 获取原对象 */

          if (key === RAW) return raw;
          const result = Reflect.get(target, key, receiver);
          /* 收集依赖 */

          track(target, key);
          /* 返回值 */

          return isObject$1(result) ? reactive(result) : result;
        },

        set(target, key, value, receiver) {
          /* 获取旧值 */
          const oldValue = target[key];
          const oldLength = target.length;
          const result = Reflect.set(target, key, value, receiver);
          /* 判断新值和旧值是否不一样 */

          if (hasChanged(oldValue, value)) {
            /* 触发依赖 */
            trigger(target, key, value);
            /* 如果是数组 判断是否依赖长度 是 判断是否改变 改变触发依赖 */

            if (isArray$1(target) && target.length !== oldLength) trigger(target, 'length');
          }

          return result;
        }

      });
      /* 添加记录 */

      reactiveMap.set(target, proxy);
      return proxy;
    }

    function ref(value) {
      /* 是否已经是响应式对象 如果是直接返回 */
      if (isRef(value)) return value;
      /* 创建响应式对象 */

      return new refImpl(value);
    }

    class refImpl {
      /* 
          都是基础类型  __rawValue 和 _value 相等
          如果是对象 
              __rawValue：原始对象
              _value：响应式对象
      */
      constructor(value) {
        this.__isRef = true;
        this.__rawValue = value;
        this._value = convert(value);
      }

      get value() {
        /* 收集依赖 */
        track(this, 'value');
        /* 返回值 */

        return this._value;
      }

      set value(value) {
        if (hasChanged(this._value, value)) {
          /* 更新数据 */
          this._value = convert(value);
          this.__rawValue = value;
          /* 触发依赖 */

          trigger(this, 'value', value);
        }
      }

    }

    function convert(value) {
      return isObject$1(value) ? reactive(value) : value;
    }
    /* 自动判断是否是 ref 并且获取值 不是 旧返回参数 */


    function unRef(ref) {
      return isRef(ref) ? ref.value : ref;
    }

    /* 返回一个函数 调用 停止监听 */

    function watchEffect(func) {
      let effectFn = effect(func);
      const deps = effectFn.deps;
      return function () {
        deps.delete(effectFn);
        effectFn = null;
      };
    }

    function watch(getter, func) {
      let _value = isRef(getter) ? getter.value : getter();

      let effectFn = effect(() => isRef(getter) ? getter.value : getter(), {
        scheduler: (effect, value) => {
          func(value, _value);
          _value = value;
        }
      });
      const deps = effectFn.deps;
      return function () {
        deps.delete(effectFn);
        effectFn = null;
        _value = null;
      };
    }

    function computed(getterOrOptions) {
      let getter, setter;

      if (isFunction(getterOrOptions)) {
        getter = getterOrOptions;

        setter = () => {
          console.warn('Write operation failed: computed value is readonly');
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }

      return new ComputedRefImpl(getter, setter);
    }

    class ComputedRefImpl {
      constructor(getter, setter) {
        this._setter = setter;
        /* 缓存结果 */

        this._value = undefined;
        /* 判断依赖值是否改变 */

        this._dirty = true;
        /* 监听依赖变化 */

        this.effect = effect(getter, {
          lazy: true,
          scheduler: () => {
            if (!this._dirty) {
              this._dirty = true;
              /* 触发依赖 */

              trigger(this, 'value', this._value);
            }
          }
        });
      }

      get value() {
        if (this._dirty) {
          this._value = this.effect();
          this._dirty = false;
          /* 收集依赖 */

          track(this, 'value');
        }

        return this._value;
      }

      set value(value) {
        this._setter(value);
      }

    }

    /* vNode 类型 */

    /* 组件实例类型 */

    /* vNode 类型判断 使用位运算 可以提高效率 */
    const ShapeFlags = {
      ELEMENT: 1,
      // 00000001 元素
      TEXT: 1 << 1,
      // 00000010 文本
      FRAGMENT: 1 << 2,
      // 00000100 容器
      COMPONENT: 1 << 3,
      // 00001000 组件
      TEXT_CHILDREN: 1 << 4,
      // 00010000 string 孩子
      ARRAY_CHILDREN: 1 << 5,
      // 00100000 数组 孩子
      CHILDREN: 1 << 4 | 1 << 5 //00110000 孩子

    };
    /* 文本唯一标识 */

    const Text = Symbol('Text');
    /* 容器唯一标识 */

    const Fragment = Symbol('Fragment');
    /* 判断是否是字符串 */

    function isString(target) {
      return typeof target === 'string';
    }
    /* 判断是否是字符串 */

    function isNumber(target) {
      return typeof target === 'number';
    }
    /* 判断是否是对象 */

    function isObject(target) {
      return typeof target === 'object' && target != null;
    }
    /* 判断是否是字符串 */

    function isArray(target) {
      return Array.isArray(target);
    }
    /* 判断是否是同类型的vNode */

    function isSameVNode(n1, n2) {
      return n1.type === n2.type;
    }
    /* 判断孩子是否都有key */

    function isChildrenKey(c1, c2) {
      let c1True = 0,
          c2True = 0;
      c1.forEach(c => {
        if (c && c['key'] != null) c1True++;
      });
      c2.forEach(c => {
        if (c && c['key'] != null) c2True++;
      });
      return c1True === c1.length && c2True === c2.length;
    }
    /* 判断 vNode 类型 */

    function vNodeType(type) {
      /* 判断是否是标签 */
      if (isString(type)) return ShapeFlags.ELEMENT;
      /* 判断是否是文本 */

      if (type === Text) return ShapeFlags.TEXT;
      /* 是否是容器 */

      if (type === Fragment) return ShapeFlags.FRAGMENT;
      /* 是否是组件 */

      return ShapeFlags.COMPONENT;
    }
    /* dom 属性正则 */

    const domPropsRE = /[A-Z]|^(value|checked|selected|muted|disabled)$/;
    /* 最长上升子序列算法 */

    function getSequence(numberArray) {
      const result = [];
      const position = [];

      for (let i = 0; i < numberArray.length; i++) {
        if (numberArray[i] === -1) {
          continue;
        } // result[result.length - 1]可能为undefined，此时numberArray[i] > undefined为false


        if (numberArray[i] > result[result.length - 1]) {
          result.push(numberArray[i]);
          position.push(result.length - 1);
        } else {
          let l = 0,
              r = result.length - 1;

          while (l <= r) {
            const mid = ~~((l + r) / 2);

            if (numberArray[i] > result[mid]) {
              l = mid + 1;
            } else if (numberArray[i] < result[mid]) {
              r = mid - 1;
            } else {
              l = mid;
              break;
            }
          }

          result[l] = numberArray[i];
          position.push(l);
        }
      }

      let cur = result.length - 1;

      for (let i = position.length - 1; i >= 0 && cur >= 0; i--) {
        if (position[i] === cur) {
          result[cur--] = i;
        }
      }

      return result;
    }

    function h(type, props, children) {
      let shapeFlag = vNodeType(type);
      /* 判断 孩子 是否是 字符串 或者 数字 */

      if (isString(children) || isNumber(children)) {
        /* 用位或运算整合 */
        shapeFlag |= ShapeFlags.TEXT_CHILDREN;
        children = children.toString();
      }
      /* 判断 孩子 是否是 数组 */


      if (isArray(children)) {
        /* 用位或运算整合 */
        shapeFlag |= ShapeFlags.ARRAY_CHILDREN;
      }

      return {
        type,
        props,
        children,
        shapeFlag,
        elm: null,
        anchor: null,
        key: props && props.key,
        component: null
      };
    }
    /* render 返回值 二次处理 */


    function normalizeVNode(result) {
      /* 数组 用 Fragment 包起来 */
      if (Array.isArray(result)) {
        return h(Fragment, null, result);
      }
      /* 对象 直接返回 */


      if (isObject(result)) {
        return result;
      }
      /* 字符串 或 数组 文Text 包起来 */


      return h(Text, null, result.toString());
    }

    /* 初始化 Props 不接的 当成 attrs属性 处理 */

    function initProps(instance, vNode) {
      const {
        type: Component,
        props: vNodeProps
      } = vNode;
      const props = instance.props = {};
      const attrs = instance.attrs = {};

      for (const key in vNodeProps) {
        if (Component.props?.includes(key)) {
          props[key] = vNodeProps[key];
        } else {
          attrs[key] = vNodeProps[key];
        }
      }
      /* props 设置成 响应式 */


      instance.props = reactive(instance.props);
    }

    function fallThrough(instance, subTree) {
      if (Object.keys(instance.attrs).length) {
        subTree.props = { ...subTree.props,
          ...instance.attrs
        };
      }
    }

    function updateComponent(n1, n2) {
      n2.component = n1.component;
      n2.component.next = n2;
      n2.component.update();
    }

    /* 更新队列 */
    const queue = [];
    /* 是否正在更新 */

    let isFlushing = false;
    /* 使用微任务更新 */

    const resolePromise = Promise.resolve();
    /* 给队列添加事件 */

    function queueJob(job) {
      if (!queue.length || !queue.includes(job)) {
        queue.push(job);
        queueFlushJob();
      }
    }
    /* 在微任务中执行事件 */


    function queueFlushJob() {
      if (!isFlushing) {
        isFlushing = true;
        resolePromise.then(flushJobs);
      }
    }

    function flushJobs() {
      try {
        for (let i = 0; i < queue.length; i++) {
          queue[i]();
        }
      } finally {
        queue.length = 0;
        isFlushing = false;
      }
    }

    /* 挂载元素 */

    function mountElement(vNode, container, anchor) {
      const {
        type,
        props,
        shapeFlag,
        children
      } = vNode;
      const el = document.createElement(type);
      if (props) patchProps(null, props, el);
      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) el.textContent = vNode.children;
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) mountChildren(children, el);
      vNode.elm = el;
      container.insertBefore(el, anchor);
    }
    /* 挂载文本 */


    function mountTextNode(vNode, container, anchor) {
      const textNode = document.createTextNode(vNode.children);
      vNode.elm = textNode;
      container.insertBefore(textNode, anchor);
    }
    /* 挂载孩子 */


    function mountChildren(children, container, anchor) {
      children.forEach(child => {
        patch(null, child, container, anchor);
      });
    }
    /* 挂载组件 */


    function mountComponent(vNode, container, anchor) {
      const {
        type: Component
      } = vNode;
      /* 实例模板 */

      const instance = vNode.component = {
        props: {},
        attrs: {},
        setupState: null,
        ctx: null,
        update: null,
        isMounted: false,
        subTree: null,
        next: null
      };
      /* 初始化 Props */

      initProps(instance, vNode);
      /* 运行 setup */

      instance.setupState = Component.setup?.(instance.props, {
        attrs: instance.attrs
      });
      /* 设置 ctx */

      instance.ctx = { ...instance.props,
        ...instance.setupState
      };
      /* 设置渲染函数 */

      instance.update = effect(() => {
        /* 判断是否未挂载 */
        if (!instance.isMounted) {
          const subTree = instance.subTree = normalizeVNode(Component.render(instance.ctx));
          /* 设置 subTree 的 props 属性 */

          fallThrough(instance, subTree);
          /* 挂载组件 */

          patch(null, subTree, container, anchor);
          instance.isMounted = true;
          vNode.elm = subTree.elm;
        } else {
          // instance.next存在，代表是被动更新。否则是主动更新
          if (instance.next) {
            vNode = instance.next;
            instance.next = null;
            initProps(instance, vNode);
            instance.ctx = { ...instance.props,
              ...instance.setupState
            };
          }
          /* 获取上一次 render 返回的 vNode */


          const prev = instance.subTree;
          const subTree = instance.subTree = normalizeVNode(Component.render(instance.ctx));
          /* 设置 subTree 的 props 属性 */

          fallThrough(instance, subTree);
          /* 对比 两次 render 返回的 vNode*/

          patch(prev, subTree, container, anchor);
          vNode.elm = subTree.elm;
        }
      }, {
        scheduler: queueJob
      });
    }

    /* 处理组件 */

    function processComponent(n1, n2, container, anchor) {
      if (n1) {
        updateComponent(n1, n2);
      } else {
        mountComponent(n2, container, anchor);
      }
    }
    /* 处理容器 */


    function processFragment(n1, n2, container, anchor) {
      const fragmentStartAnchor = n2.elm = n1 ? n1.elm : document.createTextNode('');
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : document.createTextNode('');

      if (n1) {
        patchChildren(n1, n2, container, fragmentEndAnchor);
      } else {
        container.insertBefore(fragmentStartAnchor, anchor);
        container.insertBefore(fragmentEndAnchor, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor);
      }
    }
    /* 处理文本 */


    function processText(n1, n2, container, anchor) {
      if (n1) {
        if (n1.elm?.textContent !== n2.children) n1.elm.textContent = n2.children;
        n2.elm = n1.elm;
      } else {
        mountTextNode(n2, container, anchor);
      }
    }
    /* 处理元素 */


    function processElement(n1, n2, container, anchor) {
      if (n1) {
        patchElement(n1, n2);
      } else {
        mountElement(n2, container, anchor);
      }
    }

    /* 卸载 vNode */

    function unmount(vNode) {
      const {
        shapeFlag
      } = vNode;

      if (shapeFlag & ShapeFlags.COMPONENT) {
        unmountComponent(vNode);
      } else if (shapeFlag & ShapeFlags.FRAGMENT) {
        unmountFragment(vNode);
      } else {
        unmountElementOrText(vNode);
      }
    }
    /* 卸载组件 */


    function unmountComponent(vNode) {
      unmount(vNode.component.subTree);
    }
    /* 卸载容器 */


    function unmountFragment(vNode) {
      let {
        elm: cur,
        anchor: end
      } = vNode;
      const parentNode = cur.parentNode;

      while (cur !== end) {
        const next = cur.nextSibling;
        parentNode.removeChild(cur);
        cur = next;
      }

      parentNode.removeChild(end);
    }
    /* 卸载元素或文本 */


    function unmountElementOrText(vNode) {
      const {
        elm
      } = vNode;
      elm.parentNode.removeChild(elm);
    }
    /* 卸载孩子 */


    function unmountChildren(children) {
      children.forEach(child => {
        unmount(child);
      });
    }

    function patch(n1, n2, container, anchor) {
      if (n1 && !isSameVNode(n1, n2)) {
        /* n1被卸载后，n2将会创建，因此anchor至关重要。需要将它设置为n1的下一个兄弟节点 */
        anchor = (n1.anchor || n1.elm).nextSibling;
        unmount(n1);
        n1 = null;
      }

      const {
        shapeFlag
      } = n2;
      /* 判断 n2 是否是组件 */

      if (shapeFlag & ShapeFlags.COMPONENT) processComponent(n1, n2, container, anchor);
      /* 判断 n2 是否是文本 */

      if (shapeFlag & ShapeFlags.TEXT) processText(n1, n2, container, anchor);
      /* 判断 n2 是否是元素 */

      if (shapeFlag & ShapeFlags.FRAGMENT) processFragment(n1, n2, container, anchor);
      /* 判断 n2 是否是容器 */

      if (shapeFlag & ShapeFlags.ELEMENT) processElement(n1, n2, container, anchor);
    }
    /* 更新元素 */


    function patchElement(n1, n2) {
      n2.elm = n1.elm;
      patchProps(n1.props, n2.props, n2.elm);
      patchChildren(n1, n2, n2.elm);
    }
    /* 更新属性 */


    function patchProps(oldProps, newProps, container) {
      if (oldProps === newProps) return;
      oldProps = oldProps || {};
      newProps = newProps || {};

      for (const key in newProps) {
        if (key === 'key') continue;
        const prev = oldProps[key];
        const next = newProps[key];

        if (prev !== next) {
          patchDomProp(container, key, prev, next);
        }
      }

      for (const key in oldProps) {
        if (key !== 'key' && !(key in newProps)) {
          patchDomProp(container, key, oldProps[key], null);
        }
      }
    }
    /* 更新 DOM 属性 */


    function patchDomProp(el, key, prev, next) {
      switch (key) {
        case 'class':
          // 暂时认为class就是字符串
          // next可能为null，会变成'null'，因此要设成''
          el.className = next || '';
          break;

        case 'style':
          // style为对象
          if (!next) {
            el.removeAttribute('style');
          } else {
            for (const styleName in next) {
              el.style[styleName] = next[styleName];
            }

            if (prev) {
              for (const styleName in prev) {
                if (next[styleName] == null) {
                  el.style[styleName] = '';
                }
              }
            }
          }

          break;

        default:
          if (/^on[^a-z]/.test(key)) {
            // 事件
            if (prev !== next) {
              const eventName = key.slice(2).toLowerCase();

              if (prev) {
                el.removeEventListener(eventName, prev);
              }

              if (next) {
                el.addEventListener(eventName, next);
              }
            }
          } else if (domPropsRE.test(key)) {
            if (next === '' && typeof el[key] === 'boolean') {
              next = true;
            }

            el[key] = next;
          } else {
            // 例如自定义属性{custom: ''}，应该用setAttribute设置为<input custom />
            // 而{custom: null}，应用removeAttribute设置为<input />
            if (next == null || next === false) {
              el.removeAttribute(key);
            } else {
              el.setAttribute(key, next);
            }
          }

          break;
      }
    }
    /* 更新孩子 */


    function patchChildren(n1, n2, container, anchor) {
      const {
        shapeFlag: prevShapeFlag,
        children: c1
      } = n1;
      const {
        shapeFlag,
        children: c2
      } = n2;
      /* 新 vNode 孩子是 文本 */

      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
        /* 旧 vNode 孩子是 数组  卸载孩子*/
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1);
        /* 如果 新旧孩子文本内容不一致 文本内容设置为 新孩子    PS：旧 vNode 孩子是 数组 testContent 是 null */

        if (c2 !== c1) container.textContent = c2;
        /* 新 vNode 孩子是 数组 */
      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        /* 旧 vNode 孩子是 数组*/
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          /* 判断是否有key 调用不同的 diff 算法 */
          if (isChildrenKey(c1, c2)) {
            /* 有 key 时 */
            patchKeyedChildren(c1, c2, container, anchor);
          } else {
            /* 无 key 时 */
            patchUnKeyedChildren(c1, c2, container, anchor);
          }
        } else {
          /* 旧 vNode 孩子是 文本 或 null */
          container.textContent = null;
          mountChildren(c2, container, anchor);
        }
        /* 新 vNode 孩子是 null */

      } else {
        /* 旧 vNode 孩子是 文本 */
        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) container.textContent = null;
        /* 旧 vNode 孩子是 数组 */

        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1);
      }
    }
    /* 有 key 时 使用的 diff 算法 */


    function patchKeyedChildren(c1, c2, container, anchor) {
      let start = 0,
          e1 = c1.length - 1,
          e2 = c2.length - 1;
      /* 1. 从左向右对比 */

      while (start <= e1 && start <= e2 && c1[start].key === c2[start].key) {
        patch(c1[start], c2[start], container, anchor);
        start++;
      }
      /* 2. 从右向左对比 */


      while (start <= e1 && start <= e2 && c1[e1].key === c2[e2].key) {
        patch(c1[e1], c2[e2], container, anchor);
        e1--;
        e2--;
      }
      /* 3.1 比对后 旧孩子 已无元素 */


      if (start > e1) {
        const nextPos = e2 + 1;
        const curAnchor = c2[nextPos] && c2[nextPos].elm || anchor;

        for (let i = start; i <= e2; i++) {
          patch(null, c2[i], container, curAnchor);
        }
      }
      /* 3.2 对比后 新孩子 已无元素 */


      if (start > e2) {
        for (let i = start; i <= e1; i++) {
          unmount(c1[i]);
        }
      }
      /* 4. 对比后 新旧孩子 都还有元素 采用传统diff算法，但不真的添加和移动，只做标记和删除 */


      if (start <= e1 && start <= e2) {
        /* 记录旧孩子 查询使用 */
        const map = new Map();

        for (let i = start; i <= e1; i++) {
          map.set(c1[i].key, {
            prev: c1[i],
            index: i
          });
        }
        /* 旧孩子中上一个对比元素位置下标 */


        let maxNewIndexSoFar = 0;
        /* 是否移动 开关 */

        let move = false;
        /* 旧孩子中没有没有新孩子节点的下标 给未开启 move 使用 */

        const toMounted = [];
        /* 初始化 sources 下标 数组 */

        const sources = new Array(e2 - start + 1).fill(-1);
        /* 查找新节点在旧节点的位置 并且 做标记 和 删除 map 中找到的元素 */

        for (let i = 0; i < e2 - start + 1; i++) {
          const nextPos = c2[i + start];
          /* 判断 旧孩子 中是否有 新孩子的key */

          if (map.has(nextPos.key)) {
            const {
              prev,
              index
            } = map.get(nextPos.key);
            /* 进行对比 */

            patch(prev, nextPos, container, anchor);
            /* 判断 当前位置是否需要移动  */

            if (index < maxNewIndexSoFar) {
              move = true;
            } else {
              maxNewIndexSoFar = index;
            }
            /* 设置 新旧孩子节点 下标对应关系 */


            sources[i] = index;
            /* 删除 map 中对应的 key 值 */

            map.delete(nextPos.key);
          } else {
            /* 旧孩子中未找到新孩子节点的下标存入 toMounted */
            toMounted.push(i + start);
          }
        }
        /* 删除 旧孩子 剩余元素 */


        map.forEach(_ref => {
          let {
            prev
          } = _ref;
          unmount(prev);
        });
        /* 5. 移动开关开启时 移动元素操作 采用新的最长上升子序列算法 */

        if (move) {
          /* 最长上升子序列 下标数组 */
          const sequence = getSequence(sources);
          /* 数组最长下标 */

          let length = sequence.length - 1;

          for (let i = sources.length - 1; i >= 0; i--) {
            /* 下标符合 不做移动 */
            if (i === sequence[length]) {
              length--;
            } else {
              const pos = i + start;
              const nextPos = pos + 1;
              const curAnchor = c2[nextPos] && c2[nextPos].elm || anchor;

              if (sources[i] === -1) {
                /* 旧孩子没有此节点 进行挂载 */
                patch(null, c2[pos], container, curAnchor);
              } else {
                /* 移动操作 */
                container.insertBefore(c2[pos].elm, curAnchor);
              }
            }
          }
          /* 6. 未开启 move 还有元素需要添加 情况 */

        } else if (toMounted.length) {
          for (let i = toMounted.length - 1; i >= 0; i++) {
            const pos = toMounted[i];
            const nextPos = pos + 1;
            const curAnchor = c2[nextPos] && c2[nextPos].elm || anchor;
            patch(null, c2[pos], container, curAnchor);
          }
        }
      }
    }
    /* 无 key 时 使用的 diff 算法 */


    function patchUnKeyedChildren(c1, c2, container, anchor) {
      const oldLength = c1.length;
      const newLength = c2.length;
      /* 选取最短的子数组 */

      const commonLength = Math.min(oldLength, newLength);
      /* 对比共同长度的子节点 */

      for (let i = 0; i < commonLength; i++) {
        patch(c1[i], c2[i], container, anchor);
      }
      /* 新孩子 多于 旧孩子 剩下部分 挂载孩子 */


      if (newLength > oldLength) mountChildren(c2.slice(commonLength), container, anchor);
      /* 旧孩子 多于 新孩子 剩下部分 卸载孩子 */

      if (newLength < oldLength) unmountChildren(c1.slice(commonLength));
    }

    /* 渲染函数 */

    function render(vNode, container) {
      const pervVNode = container._vNode;
      /*  判断是否传入新的vNode */

      if (vNode) {
        /* 进行 diff 算法 */
        patch(pervVNode, vNode, container);
      } else {
        /* 没有传入新的 vNode 且有旧的 vNode 卸载旧 vNode */
        if (pervVNode) unmount(pervVNode);
      }

      container._vNode = vNode;
    }

    function createApp(component) {
      return {
        mount(container) {
          if (isString(container)) container = document.querySelector(container);
          render(h(component, null, null), container);
        }

      };
    }

    exports.Fragment = Fragment;
    exports.Text = Text;
    exports.computed = computed;
    exports.createApp = createApp;
    exports.h = h;
    exports.isReactive = isReactive;
    exports.isRef = isRef;
    exports.reactive = reactive;
    exports.ref = ref;
    exports.render = render;
    exports.toRaw = toRaw;
    exports.unRef = unRef;
    exports.watch = watch;
    exports.watchEffect = watchEffect;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=rainCore.min.js.map
