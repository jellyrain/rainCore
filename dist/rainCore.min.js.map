{"version":3,"file":"rainCore.min.js","sources":["../src/reactivity/utils.ts","../src/reactivity/effect.ts","../src/reactivity/reactive.ts","../src/reactivity/ref.ts","../src/reactivity/computed.ts","../src/runtime/utils.ts","../src/runtime/vnode.ts","../src/runtime/component.ts","../src/runtime/scheduler.ts","../src/runtime/mount.ts","../src/runtime/process.ts","../src/runtime/patch.ts","../src/runtime/unmount.ts","../src/runtime/render.ts","../src/compiler/utils.ts","../src/compiler/ast.ts","../src/compiler/parse.ts","../src/codegen/directives.ts","../src/codegen/utils.ts","../src/codegen/codegen.ts","../src/codegen/compile.ts","../src/codegen/createApp.ts","../src/runtime/renderList.ts","../src/reactivity/watch.ts","../src/reactivity/watchEffect.ts"],"sourcesContent":["/* reactive 响应式标识 */\r\nexport const IS_REACTIVE: string = '__isReactive'\r\n/* reactive 响应式标识 */\r\nexport const IS_REF: string = '__isRef'\r\n/* 代理前对象标识 */\r\nexport const RAW: string = '__raw'\r\n\r\n/* 判断是否是对象 */\r\nexport function isObject(target: any) {\r\n    return typeof target === 'object' && target != null\r\n}\r\n\r\n/* 判断是否是数组 */\r\nexport function isArray(target: any) {\r\n    return Array.isArray(target)\r\n}\r\n\r\n/* 判断是否是函数 */\r\nexport function isFunction(target: any) {\r\n    return typeof target === 'function' && target != null\r\n}\r\n\r\n/* 判断是否是 reactive 响应式对象 */\r\nexport function isReactive(target: any) {\r\n    return !!(target && target[IS_REACTIVE])\r\n\r\n}\r\n\r\n/* 判断是否是 ref 响应式对象 */\r\nexport function isRef(value: any) {\r\n    return !!(value && value[IS_REF])\r\n}\r\n\r\n/* 判断两个值是否一致 */\r\nexport function hasChanged(oldValue: any, newValue: any) {\r\n    return oldValue !== newValue && !(Number.isNaN(oldValue) || Number.isNaN(newValue))\r\n}","const effectStack: any = []\r\n/* 暴露依赖 */\r\nlet activeEffect: any\r\n\r\nfunction effect(func: Function, options: any = {}): Function {\r\n    const effectFn = () => {\r\n        try {\r\n            effectStack.push(effectFn)\r\n            activeEffect = effectFn\r\n            return func()\r\n        } finally {\r\n            effectStack.pop()\r\n            activeEffect = effectStack[effectStack.length - 1]\r\n        }\r\n    }\r\n    /* 是否先执行一次 */\r\n    if (!options.lazy) effectFn()\r\n\r\n    effectFn.scheduler = options.scheduler\r\n\r\n    return effectFn\r\n}\r\n\r\n/* 收集依赖 */\r\nconst targetMap: WeakMap<object, any> = new WeakMap()\r\n\r\nfunction track(target: any, key: string | symbol): void {\r\n    /* 是否有依赖需要收集 没有直接发返回 */\r\n    if (!activeEffect) return\r\n    /* \r\n        查找是否有此响应式数据对应的依赖组 \r\n        如果没有为该数据创建 Map \r\n    */\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) targetMap.set(target, (depsMap = new Map()))\r\n    /* \r\n        查找是否有此响应式数据内数据的依赖组 \r\n        如果没有为该数据创建 Set \r\n    */\r\n    let deps = depsMap.get(key)\r\n    if (!deps) depsMap.set(key, (deps = new Set()))\r\n    /* 把用到此数据的依赖挂载到 effectFn 上 提供删除 */\r\n    activeEffect.deps = deps\r\n    /* 添加依赖 */\r\n    deps.add(activeEffect)\r\n}\r\n\r\n/* 触发依赖 */\r\nfunction trigger(target: any, key: string | symbol, value?: any): void {\r\n    const depsMap = targetMap.get(target)\r\n    /* \r\n        查找是否有此响应式数据对应的依赖组 \r\n        没有就直接返回\r\n    */\r\n    if (!depsMap) return\r\n    /* \r\n       查找是否有此响应式数据内数据的依赖组 \r\n       没有就直接返回\r\n    */\r\n    const deps = depsMap.get(key)\r\n    if (!deps) return\r\n    /* 触发依赖 */\r\n    deps.forEach((effect: { (): any; scheduler: (effect: any, value: any) => any }) => {\r\n        /* 有调度 scheduler 优先触发 scheduler */\r\n        effect.scheduler ? effect.scheduler(effect, value) : effect()\r\n    })\r\n}\r\n\r\nexport { effect, track, trigger, targetMap }","import { IS_REACTIVE, RAW, isObject, isArray, isReactive, hasChanged } from './utils'\r\nimport { track, trigger } from './effect'\r\n\r\n/* 保存响应式对象 */\r\nconst reactiveMap = new WeakMap()\r\n\r\nfunction reactive(target: any) {\r\n    /* 如果不是对象直接返回 */\r\n    if (!isObject(target)) return target\r\n    /* 是否已经是响应式对象 如果是直接返回 */\r\n    if (isReactive(target)) return target\r\n    /* 如果对象已经做过响应式 就直接返沪响应式对象 */\r\n    if (reactiveMap.has(target)) return reactiveMap.get(target)\r\n    /* 创建响应式对象 */\r\n    return createReactiveObject(target)\r\n}\r\n\r\n/* 提供一个响应式对象，返回原始对象 */\r\nfunction toRaw(target: any) {\r\n    if (isReactive(target)) return target[RAW]\r\n}\r\n\r\nfunction createReactiveObject(target: any) {\r\n    const raw = target\r\n    const proxy: any = new Proxy(target, {\r\n        get(target, key, receiver) {\r\n            /* 判断是否是响应式对象 */\r\n            if (key === IS_REACTIVE) return true\r\n            /* 获取原对象 */\r\n            if (key === RAW) return raw\r\n\r\n            const result = Reflect.get(target, key, receiver)\r\n            /* 收集依赖 */\r\n            track(target, key)\r\n            /* 返回值 */\r\n            return isObject(result) ? reactive(result) : result\r\n        },\r\n        set(target, key, value, receiver) {\r\n            /* 获取旧值 */\r\n            const oldValue = target[key]\r\n            const oldLength = target.length\r\n\r\n            const result = Reflect.set(target, key, value, receiver)\r\n            /* 判断新值和旧值是否不一样 */\r\n            if (hasChanged(oldValue, value)) {\r\n                /* 触发依赖 */\r\n                trigger(target, key, value)\r\n                /* 如果是数组 判断是否依赖长度 是 判断是否改变 改变触发依赖 */\r\n                if (isArray(target) && target.length !== oldLength) trigger(target, 'length')\r\n            }\r\n            return result\r\n        }\r\n    })\r\n    /* 添加记录 */\r\n    reactiveMap.set(target, proxy)\r\n    return proxy\r\n}\r\n\r\nexport { reactive, toRaw }","import { isObject, isRef, hasChanged } from './utils'\r\nimport { reactive } from './reactive'\r\nimport { track, trigger } from './effect'\r\n\r\nfunction ref(value: any) {\r\n    /* 是否已经是响应式对象 如果是直接返回 */\r\n    if (isRef(value)) return value\r\n    /* 创建响应式对象 */\r\n    return new refImpl(value)\r\n}\r\n\r\nclass refImpl {\r\n    private __rawValue: any\r\n    private __isRef: boolean\r\n    private _value: any\r\n    /* \r\n        都是基础类型  __rawValue 和 _value 相等\r\n        如果是对象 \r\n            __rawValue：原始对象\r\n            _value：响应式对象\r\n    */\r\n    constructor(value: any) {\r\n        this.__isRef = true\r\n        this.__rawValue = value\r\n        this._value = convert(value)\r\n    }\r\n\r\n    get value() {\r\n        /* 收集依赖 */\r\n        track(this, 'value')\r\n        /* 返回值 */\r\n        return this._value\r\n    }\r\n\r\n    set value(value) {\r\n        if (hasChanged(this._value, value)) {\r\n            /* 更新数据 */\r\n            this._value = convert(value)\r\n            this.__rawValue = value\r\n            /* 触发依赖 */\r\n            trigger(this, 'value', value)\r\n        }\r\n    }\r\n}\r\n\r\nfunction convert(value: any) {\r\n    return isObject(value) ? reactive(value) : value\r\n}\r\n\r\n/* 自动判断是否是 ref 并且获取值 不是 旧返回参数 */\r\nfunction unRef(ref: any) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\n\r\nexport { ref, unRef }","import { track, trigger, effect } from './effect'\r\nimport { isFunction } from './utils'\r\n\r\nfunction computed(getterOrOptions: any): ComputedRefImpl {\r\n    let getter, setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions\r\n        setter = () => {\r\n            console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n    } else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter)\r\n}\r\n\r\nclass ComputedRefImpl {\r\n    private _setter: Function\r\n    private _value: any\r\n    private _dirty: boolean\r\n    private effect: any\r\n    constructor(getter: Function, setter: Function) {\r\n        this._setter = setter\r\n        /* 缓存结果 */\r\n        this._value = undefined\r\n        /* 判断依赖值是否改变 */\r\n        this._dirty = true\r\n        /* 监听依赖变化 */\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true\r\n                    /* 触发依赖 */\r\n                    trigger(this, 'value', this._value)\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect()\r\n            this._dirty = false\r\n            /* 收集依赖 */\r\n            track(this, 'value')\r\n        }\r\n        return this._value\r\n    }\r\n\r\n    set value(value) {\r\n        this._setter(value)\r\n    }\r\n}\r\n\r\nexport { computed }","/* vNode 类型 */\r\nexport type vNode = {\r\n    /* 类型 */\r\n    type: string | Symbol | object,\r\n    /* 属性 */\r\n    props: object | null,\r\n    /* 孩子 */\r\n    children: string | number | [] | null,\r\n    /* 类型标签 */\r\n    shapeFlag: number,\r\n    /* DOM 节点 */\r\n    elm: HTMLElement | Text | null,\r\n    /* Fragment 专属属性 anchor */\r\n    anchor: Text | null,\r\n    /* key */\r\n    key: string | null,\r\n    /* 组件的实例 */\r\n    component: object | null\r\n}\r\n\r\n/* 组件实例类型 */\r\nexport type instance = {\r\n    /* 接收夫组件传递的数据 */\r\n    props: object | null,\r\n    /* vNode 上的属性 */\r\n    attrs: object | null,\r\n    /* setup 函数返回对象 */\r\n    setupState: object | null,\r\n    /* ctx 渲染函数参数 */\r\n    ctx: object | null,\r\n    /* 渲染函数 */\r\n    update: object | null,\r\n    /* 组件是否挂载 */\r\n    isMounted: boolean,\r\n    /* render 函数 返回结果 */\r\n    subTree: object | null,\r\n    /* 组件更新时，把新 vNode暂放在这里 */\r\n    next: object | null\r\n}\r\n\r\n/* vNode 类型判断 使用位运算 可以提高效率 */\r\nexport const ShapeFlags = {\r\n    ELEMENT: 1, // 00000001 元素\r\n    TEXT: 1 << 1, // 00000010 文本\r\n    FRAGMENT: 1 << 2, // 00000100 容器\r\n    COMPONENT: 1 << 3, // 00001000 组件\r\n    TEXT_CHILDREN: 1 << 4, // 00010000 string 孩子\r\n    ARRAY_CHILDREN: 1 << 5, // 00100000 数组 孩子\r\n    CHILDREN: (1 << 4) | (1 << 5), //00110000 孩子\r\n}\r\n\r\n/* 文本唯一标识 */\r\nexport const Text = Symbol('Text')\r\n\r\n/* 容器唯一标识 */\r\nexport const Fragment = Symbol('Fragment')\r\n\r\n/* 判断是否是字符串 */\r\nexport function isString(target: any) {\r\n    return typeof target === 'string'\r\n}\r\n\r\n/* 判断是否是字符串 */\r\nexport function isNumber(target: any) {\r\n    return typeof target === 'number'\r\n}\r\n\r\n/* 判断是否是对象 */\r\nexport function isObject(target: any) {\r\n    return typeof target === 'object' && target != null\r\n}\r\n\r\n/* 判断是否是字符串 */\r\nexport function isArray(target: any) {\r\n    return Array.isArray(target)\r\n}\r\n\r\n/* 判断是否是同类型的vNode */\r\nexport function isSameVNode(n1: vNode, n2: vNode) {\r\n    return n1.type === n2.type\r\n}\r\n\r\n/* 判断孩子是否都有key */\r\nexport function isChildrenKey(c1: [], c2: []) {\r\n    let c1True = 0, c2True = 0\r\n    c1.forEach(c => {\r\n        if (c && c['key'] != null) c1True++\r\n    })\r\n    c2.forEach(c => {\r\n        if (c && c['key'] != null) c2True++\r\n    })\r\n    return c1True === c1.length && c2True === c2.length\r\n}\r\n\r\n/* 判断 vNode 类型 */\r\nexport function vNodeType(type: string | Symbol | object): number {\r\n    /* 判断是否是标签 */\r\n    if (isString(type)) return ShapeFlags.ELEMENT\r\n    /* 判断是否是文本 */\r\n    if (type === Text) return ShapeFlags.TEXT\r\n    /* 是否是容器 */\r\n    if (type === Fragment) return ShapeFlags.FRAGMENT\r\n    /* 是否是组件 */\r\n    return ShapeFlags.COMPONENT\r\n}\r\n\r\n/* dom 属性正则 */\r\nexport const domPropsRE = /[A-Z]|^(value|checked|selected|muted|disabled)$/\r\n\r\n/* 最长上升子序列算法 */\r\nexport function getSequence(numberArray: []) {\r\n    const result: any = [];\r\n    const position = [];\r\n    for (let i = 0; i < numberArray.length; i++) {\r\n        if (numberArray[i] === -1) {\r\n            continue;\r\n        }\r\n        // result[result.length - 1]可能为undefined，此时numberArray[i] > undefined为false\r\n        if (numberArray[i] > result[result.length - 1]) {\r\n            result.push(numberArray[i]);\r\n            position.push(result.length - 1);\r\n        } else {\r\n            let l = 0,\r\n                r = result.length - 1;\r\n            while (l <= r) {\r\n                const mid = ~~((l + r) / 2);\r\n                if (numberArray[i] > result[mid]) {\r\n                    l = mid + 1;\r\n                } else if (numberArray[i] < result[mid]) {\r\n                    r = mid - 1;\r\n                } else {\r\n                    l = mid;\r\n                    break;\r\n                }\r\n            }\r\n            result[l] = numberArray[i];\r\n            position.push(l);\r\n        }\r\n    }\r\n    let cur = result.length - 1;\r\n    for (let i = position.length - 1; i >= 0 && cur >= 0; i--) {\r\n        if (position[i] === cur) {\r\n            result[cur--] = i;\r\n        }\r\n    }\r\n    return result;\r\n}","import { vNode, isString, isNumber, isArray, ShapeFlags, vNodeType, Fragment, Text, isObject } from './utils'\r\n\r\nfunction h(type: string | Symbol | object, props: object | null, children: string | number | [] | null): vNode {\r\n    let shapeFlag: number = vNodeType(type)\r\n\r\n    /* 判断 孩子 是否是 字符串 或者 数字 */\r\n    if (isString(children) || isNumber(children)) {\r\n        /* 用位或运算整合 */\r\n        shapeFlag |= ShapeFlags.TEXT_CHILDREN\r\n        children = children!.toString()\r\n    }\r\n\r\n    /* 判断 孩子 是否是 数组 */\r\n    if (isArray(children)) {\r\n        /* 用位或运算整合 */\r\n        shapeFlag |= ShapeFlags.ARRAY_CHILDREN\r\n    }\r\n\r\n    return { type, props, children, shapeFlag, elm: null, anchor: null, key: props && (props as any).key, component: null }\r\n}\r\n\r\n/* render 返回值 二次处理 */\r\nfunction normalizeVNode(result: any) {\r\n    /* 数组 用 Fragment 包起来 */\r\n    if (Array.isArray(result)) {\r\n        return h(Fragment, null, result as any);\r\n    }\r\n    /* 对象 直接返回 */\r\n    if (isObject(result)) {\r\n        return result;\r\n    }\r\n    /* 字符串 或 数组 文Text 包起来 */\r\n    return h(Text, null, result.toString());\r\n}\r\n\r\nexport { h, normalizeVNode }","import { instance, vNode } from './utils'\r\nimport { reactive } from '../reactivity/index'\r\n\r\n/* 初始化 Props 不接的 当成 attrs属性 处理 */\r\nfunction initProps(instance: instance, vNode: vNode) {\r\n    const { type: Component, props: vNodeProps } = vNode\r\n    const props: any = (instance.props = {})\r\n    const attrs: any = (instance.attrs = {})\r\n    for (const key in vNodeProps) {\r\n        if ((Component as any).props?.includes(key)) {\r\n            props[key] = (vNodeProps as any)[key];\r\n        } else {\r\n            attrs[key] = (vNodeProps as any)[key];\r\n        }\r\n    }\r\n    /* props 设置成 响应式 */\r\n    instance.props = reactive(instance.props)\r\n}\r\n\r\nfunction fallThrough(instance: instance, subTree: vNode) {\r\n    if (Object.keys((instance as any).attrs).length) {\r\n        subTree.props = {\r\n            ...subTree.props,\r\n            ...instance.attrs,\r\n        };\r\n    }\r\n}\r\n\r\nfunction updateComponent(n1: vNode | null, n2: vNode) {\r\n    n2.component = n1!.component;\r\n    (n2.component as any).next = n2;\r\n    (n2.component as any).update()\r\n}\r\n\r\nexport { initProps, fallThrough, updateComponent }","/* 更新队列 */\r\nconst queue: any = []\r\n/* 是否正在更新 */\r\nlet isFlushing = false\r\n/* 使用微任务更新 */\r\nconst resolePromise = Promise.resolve()\r\nlet currentFlushingPromise: Promise<void> | null = null\r\n\r\n/* 给队列添加事件 */\r\nfunction queueJob(job: any) {\r\n    if (!queue.length || !queue.includes(job)) {\r\n        queue.push(job)\r\n        queueFlushJob()\r\n    }\r\n}\r\n\r\n/* 在微任务中执行事件 */\r\nfunction queueFlushJob() {\r\n    if (!isFlushing) {\r\n        isFlushing = true\r\n        currentFlushingPromise = resolePromise.then(flushJobs)\r\n    }\r\n}\r\n\r\nfunction flushJobs() {\r\n    try {\r\n        for (let i = 0; i < queue.length; i++) {\r\n            queue[i]()\r\n        }\r\n    } finally {\r\n        queue.length = 0\r\n        currentFlushingPromise = null\r\n        isFlushing = false\r\n    }\r\n}\r\n\r\n/* 将回调推迟到下一个 DOM 更新周期之后执行 */\r\nfunction nextTick(func: Function) {\r\n    const p = currentFlushingPromise || resolePromise\r\n    return func ? p.then(func as any) : p\r\n}\r\n\r\nexport { queueJob, nextTick }","import { vNode, instance, ShapeFlags } from './utils'\r\nimport { patch, patchProps } from './patch'\r\nimport { initProps, fallThrough } from './component'\r\nimport { effect } from '../reactivity/effect'\r\nimport { normalizeVNode } from './vnode'\r\nimport { queueJob } from './scheduler'\r\n\r\n/* 挂载元素 */\r\nfunction mountElement(vNode: vNode, container: HTMLElement, anchor?: Text) {\r\n    const { type, props, shapeFlag, children } = vNode\r\n    const el = document.createElement(type as string)\r\n    if (props) patchProps(null, props, el)\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) el.textContent = vNode.children as string\r\n    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) mountChildren(children as [], el)\r\n    vNode.elm = el\r\n    container.insertBefore(el, anchor as Text)\r\n}\r\n\r\n/* 挂载文本 */\r\nfunction mountTextNode(vNode: vNode, container: HTMLElement, anchor?: Text) {\r\n    const textNode = document.createTextNode(vNode.children as string)\r\n    vNode.elm = textNode\r\n    container.insertBefore(textNode, anchor as Text)\r\n}\r\n\r\n/* 挂载孩子 */\r\nfunction mountChildren(children: [], container: HTMLElement, anchor?: Text) {\r\n    children.forEach(child => {\r\n        patch(null, child, container, anchor!)\r\n    })\r\n}\r\n\r\n/* 挂载组件 */\r\nfunction mountComponent(vNode: vNode, container: HTMLElement, anchor?: Text) {\r\n    const { type: Component } = vNode\r\n    /* 实例模板 */\r\n    const instance: instance = (vNode.component = {\r\n        props: {},\r\n        attrs: {},\r\n        setupState: null,\r\n        ctx: null,\r\n        update: null,\r\n        isMounted: false,\r\n        subTree: null,\r\n        next: null\r\n    })\r\n    /* 初始化 Props */\r\n    initProps(instance, vNode)\r\n    /* 运行 setup */\r\n    instance.setupState = (Component as any).setup?.(instance.props, {\r\n        attrs: instance.attrs\r\n    })\r\n    /* 设置 ctx */\r\n    instance.ctx = { ...instance.props, ...instance.setupState }\r\n    /* 设置渲染函数 */\r\n    instance.update = effect(\r\n        () => {\r\n            /* 判断是否未挂载 */\r\n            if (!instance.isMounted) {\r\n                const subTree: vNode = (instance.subTree = normalizeVNode(\r\n                    (Component as any).render(instance.ctx)\r\n                ))\r\n                /* 设置 subTree 的 props 属性 */\r\n                fallThrough(instance, subTree)\r\n                /* 挂载组件 */\r\n                patch(null, subTree, container, anchor)\r\n                instance.isMounted = true\r\n                vNode.elm = subTree.elm\r\n            } else {\r\n                // instance.next存在，代表是被动更新。否则是主动更新\r\n                if (instance.next) {\r\n                    (vNode as any) = instance.next\r\n                    instance.next = null\r\n                    initProps(instance, vNode)\r\n                    instance.ctx = { ...instance.props, ...instance.setupState, }\r\n                }\r\n                /* 获取上一次 render 返回的 vNode */\r\n                const prev: any = instance.subTree\r\n                const subTree = (instance.subTree = normalizeVNode(\r\n                    (Component as any).render(instance.ctx)\r\n                ))\r\n                /* 设置 subTree 的 props 属性 */\r\n                fallThrough(instance, subTree)\r\n                /* 对比 两次 render 返回的 vNode*/\r\n                patch(prev, subTree, container, anchor)\r\n                vNode.elm = subTree.elm\r\n            }\r\n        }, {\r\n        scheduler: queueJob\r\n    })\r\n}\r\n\r\nexport { mountElement, mountTextNode, mountChildren, mountComponent }","import { vNode } from './utils'\r\nimport { patchElement, patchChildren } from './patch'\r\nimport { mountElement, mountTextNode, mountChildren, mountComponent } from './mount'\r\nimport { updateComponent } from './component'\r\n\r\n/* 处理组件 */\r\nfunction processComponent(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    if (n1) {\r\n        updateComponent(n1, n2)\r\n    } else {\r\n        mountComponent(n2, container, anchor)\r\n    }\r\n}\r\n\r\n/* 处理容器 */\r\nfunction processFragment(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    const fragmentStartAnchor = n2.elm = n1 ? n1!.elm : document.createTextNode('')\r\n    const fragmentEndAnchor = n2.anchor = n1 ? n1!.anchor : document.createTextNode('')\r\n\r\n    if (n1) {\r\n        patchChildren(n1, n2, container, fragmentEndAnchor as Text)\r\n    } else {\r\n        container.insertBefore(fragmentStartAnchor as Text, anchor as Text)\r\n        container.insertBefore(fragmentEndAnchor as Text, anchor as Text)\r\n        mountChildren(n2.children as [], container, fragmentEndAnchor as Text)\r\n    }\r\n}\r\n\r\n/* 处理文本 */\r\nfunction processText(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    if (n1) {\r\n        if (n1.elm?.textContent !== n2.children) (n1 as any).elm.textContent = n2.children\r\n        n2.elm = n1.elm\r\n    } else {\r\n        mountTextNode(n2, container, anchor)\r\n    }\r\n}\r\n\r\n/* 处理元素 */\r\nfunction processElement(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    if (n1) {\r\n        patchElement(n1, n2)\r\n    } else {\r\n        mountElement(n2, container, anchor)\r\n    }\r\n}\r\n\r\nexport { processComponent, processFragment, processText, processElement } ","import { vNode, isSameVNode, ShapeFlags, domPropsRE, isChildrenKey, getSequence, isString, isObject } from \"./utils\"\r\nimport { processComponent, processFragment, processText, processElement } from './process'\r\nimport { unmount, unmountChildren } from './unmount'\r\nimport { mountChildren } from './mount'\r\n\r\nfunction patch(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    if (n1 && !isSameVNode(n1, n2)) {\r\n        /* n1被卸载后，n2将会创建，因此anchor至关重要。需要将它设置为n1的下一个兄弟节点 */\r\n        (anchor as any) = (n1.anchor || n1.elm)!.nextSibling\r\n        unmount(n1)\r\n        n1 = null\r\n    }\r\n    const { shapeFlag } = n2\r\n    /* 判断 n2 是否是组件 */\r\n    if (shapeFlag & ShapeFlags.COMPONENT) processComponent(n1, n2, container, anchor)\r\n    /* 判断 n2 是否是文本 */\r\n    if (shapeFlag & ShapeFlags.TEXT) processText(n1, n2, container, anchor)\r\n    /* 判断 n2 是否是元素 */\r\n    if (shapeFlag & ShapeFlags.FRAGMENT) processFragment(n1, n2, container, anchor)\r\n    /* 判断 n2 是否是容器 */\r\n    if (shapeFlag & ShapeFlags.ELEMENT) processElement(n1, n2, container, anchor)\r\n}\r\n\r\n/* 更新元素 */\r\nfunction patchElement(n1: vNode | null, n2: vNode) {\r\n    n2.elm = n1!.elm\r\n    patchProps(n1!.props as object, n2.props as object, n2.elm as HTMLElement)\r\n    patchChildren(n1, n2, n2.elm as HTMLElement)\r\n}\r\n\r\n/* 更新属性 */\r\nfunction patchProps(oldProps: object | null, newProps: object | null, container: HTMLElement) {\r\n    if (oldProps === newProps) return\r\n    oldProps = oldProps || {}\r\n    newProps = newProps || {}\r\n    for (const key in newProps) {\r\n        if (key === 'key') continue\r\n        const prev = (oldProps as any)[key]\r\n        const next = (newProps as any)[key]\r\n        if (prev !== next) {\r\n            patchDomProp(container, key, prev, next)\r\n        }\r\n    }\r\n    for (const key in oldProps) {\r\n        if (key !== 'key' && !(key in newProps)) {\r\n            patchDomProp(container, key, (oldProps as any)[key], null)\r\n        }\r\n    }\r\n}\r\n\r\n/* 更新 DOM 属性 */\r\nfunction patchDomProp(el: HTMLElement, key: string, prev: string | object, next: string | object | null) {\r\n    switch (key) {\r\n        case 'class':\r\n            // class 是 对象\r\n            if (isObject(next)) {\r\n                let temp: string = ''\r\n                for (key in (next as any)) {\r\n                    if ((next as any)[key]) temp = temp + key + ' '\r\n                }\r\n                next = temp.trim()\r\n            }\r\n            // class 是 字符串\r\n            // next可能为null，会变成'null'，因此要设成''\r\n            el.className = next as string || ''\r\n            break\r\n        case 'style':\r\n            // style为对象\r\n            if (!next) {\r\n                el.removeAttribute('style')\r\n            } else {\r\n                // style 是 字符串\r\n                if (isString(next)) {\r\n                    let str: any = next\r\n                    const result: any = {}\r\n                    str = str.split(';')\r\n                    str.forEach((item: any) => {\r\n                        const temp = item.split(':')\r\n                        if (temp.length === 2) result[temp[0].trim()] = temp[1].trim()\r\n                    })\r\n                    next = result\r\n                }\r\n                // style 是 对象\r\n                for (const styleName in next as object) {\r\n                    (el.style as any)[styleName] = (next as any)[styleName]\r\n                }\r\n                if (prev) {\r\n                    for (const styleName in prev as object) {\r\n                        if ((next as any)[styleName] == null) {\r\n                            (el.style as any)[styleName] = ''\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            break\r\n        default:\r\n            if (/^on[^a-z]/.test(key)) {\r\n                // 事件\r\n                if (prev !== next) {\r\n                    const eventName = key.slice(2).toLowerCase()\r\n                    if (prev) {\r\n                        (el.removeEventListener as any)(eventName, prev)\r\n                    }\r\n                    if (next) {\r\n                        (el.addEventListener as any)(eventName, next)\r\n                    }\r\n                }\r\n            } else if (domPropsRE.test(key)) {\r\n                if (next === '' && typeof (el as any)[key] === 'boolean') {\r\n                    (next as any) = true\r\n                }\r\n                (el as any)[key] = next\r\n            } else {\r\n                // 例如自定义属性{custom: ''}，应该用setAttribute设置为<input custom />\r\n                // 而{custom: null}，应用removeAttribute设置为<input />\r\n                if (next == null || next as any === false) {\r\n                    el.removeAttribute(key)\r\n                } else {\r\n                    el.setAttribute(key, (next as any))\r\n                }\r\n            }\r\n            break\r\n    }\r\n}\r\n\r\n/* 更新孩子 */\r\nfunction patchChildren(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    const { shapeFlag: prevShapeFlag, children: c1 } = n1!\r\n    const { shapeFlag, children: c2 } = n2\r\n\r\n    /* 新 vNode 孩子是 文本 */\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n        /* 旧 vNode 孩子是 数组  卸载孩子*/\r\n        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1 as [])\r\n        /* 如果 新旧孩子文本内容不一致 文本内容设置为 新孩子    PS：旧 vNode 孩子是 数组 testContent 是 null */\r\n        if (c2 !== c1) container.textContent = c2 as string | null\r\n\r\n        /* 新 vNode 孩子是 数组 */\r\n    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        /* 旧 vNode 孩子是 数组*/\r\n        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n            /* 判断是否有key 调用不同的 diff 算法 */\r\n            if (isChildrenKey(c1 as [], c2 as [])) {\r\n                /* 有 key 时 */\r\n                patchKeyedChildren(c1 as [], c2 as [], container, anchor)\r\n            } else {\r\n                /* 无 key 时 */\r\n                patchUnKeyedChildren(c1 as [], c2 as [], container, anchor)\r\n            }\r\n        } else {\r\n            /* 旧 vNode 孩子是 文本 或 null */\r\n            container.textContent = null\r\n            mountChildren(c2 as [], container, anchor)\r\n        }\r\n\r\n        /* 新 vNode 孩子是 null */\r\n    } else {\r\n        /* 旧 vNode 孩子是 文本 */\r\n        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) container.textContent = null\r\n        /* 旧 vNode 孩子是 数组 */\r\n        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1 as [])\r\n    }\r\n}\r\n\r\n/* 有 key 时 使用的 diff 算法 */\r\nfunction patchKeyedChildren(c1: [], c2: [], container: HTMLElement, anchor?: Text) {\r\n    let start = 0, e1 = c1.length - 1, e2 = c2.length - 1\r\n    /* 1. 从左向右对比 */\r\n    while (start <= e1 && start <= e2 && (c1[start] as any).key === (c2[start] as any).key) {\r\n        patch(c1[start], c2[start], container, anchor)\r\n        start++\r\n    }\r\n    /* 2. 从右向左对比 */\r\n    while (start <= e1 && start <= e2 && (c1 as any)[e1].key === (c2 as any)[e2].key) {\r\n        patch((c1 as any)[e1], (c2 as any)[e2], container, anchor)\r\n        e1--\r\n        e2--\r\n    }\r\n    /* 3.1 比对后 旧孩子 已无元素 */\r\n    if (start > e1) {\r\n        const nextPos = e2 + 1\r\n        const curAnchor = (c2[nextPos] && (c2[nextPos] as any).elm) || anchor\r\n        for (let i = start; i <= e2; i++) {\r\n            patch(null, c2[i], container, curAnchor)\r\n        }\r\n    }\r\n    /* 3.2 对比后 新孩子 已无元素 */\r\n    if (start > e2) {\r\n        for (let i = start; i <= e1; i++) {\r\n            unmount(c1[i])\r\n        }\r\n    }\r\n    /* 4. 对比后 新旧孩子 都还有元素 采用传统diff算法，但不真的添加和移动，只做标记和删除 */\r\n    if (start <= e1 && start <= e2) {\r\n        /* 记录旧孩子 查询使用 */\r\n        const map = new Map()\r\n        for (let i = start; i <= e1; i++) {\r\n            map.set((c1[i] as any).key, { prev: c1[i], index: i })\r\n        }\r\n        /* 旧孩子中上一个对比元素位置下标 */\r\n        let maxNewIndexSoFar = 0\r\n        /* 是否移动 开关 */\r\n        let move = false\r\n        /* 旧孩子中没有没有新孩子节点的下标 给未开启 move 使用 */\r\n        const toMounted = []\r\n        /* 初始化 sources 下标 数组 */\r\n        const sources = new Array(e2 - start + 1).fill(-1)\r\n        /* 查找新节点在旧节点的位置 并且 做标记 和 删除 map 中找到的元素 */\r\n        for (let i = 0; i < e2 - start + 1; i++) {\r\n            const nextPos: any = c2[i + start]\r\n            /* 判断 旧孩子 中是否有 新孩子的key */\r\n            if (map.has(nextPos.key)) {\r\n                const { prev, index } = map.get(nextPos.key);\r\n                /* 进行对比 */\r\n                patch(prev, nextPos, container, anchor)\r\n                /* 判断 当前位置是否需要移动  */\r\n                if (index < maxNewIndexSoFar) {\r\n                    move = true\r\n                } else {\r\n                    maxNewIndexSoFar = index\r\n                }\r\n                /* 设置 新旧孩子节点 下标对应关系 */\r\n                sources[i] = index\r\n                /* 删除 map 中对应的 key 值 */\r\n                map.delete(nextPos.key)\r\n            } else {\r\n                /* 旧孩子中未找到新孩子节点的下标存入 toMounted */\r\n                toMounted.push(i + start)\r\n            }\r\n        }\r\n        /* 删除 旧孩子 剩余元素 */\r\n        map.forEach(({ prev }) => {\r\n            unmount(prev)\r\n        })\r\n        /* 5. 移动开关开启时 移动元素操作 采用新的最长上升子序列算法 */\r\n        if (move) {\r\n            /* 最长上升子序列 下标数组 */\r\n            const sequence: any = getSequence(sources as any)\r\n            /* 数组最长下标 */\r\n            let length = sequence.length - 1\r\n            for (let i = sources.length - 1; i >= 0; i--) {\r\n                /* 下标符合 不做移动 */\r\n                if (i === sequence[length]) {\r\n                    length--\r\n                } else {\r\n                    const pos = i + start\r\n                    const nextPos = pos + 1;\r\n                    const curAnchor = (c2[nextPos] && (c2[nextPos] as any).elm) || anchor\r\n                    if (sources[i] === -1) {\r\n                        /* 旧孩子没有此节点 进行挂载 */\r\n                        patch(null, c2[pos], container, curAnchor)\r\n                    } else {\r\n                        /* 移动操作 */\r\n                        container.insertBefore((c2[pos] as any).elm, curAnchor)\r\n                    }\r\n                }\r\n            }\r\n            /* 6. 未开启 move 还有元素需要添加 情况 */\r\n        } else if (toMounted.length) {\r\n            for (let i = toMounted.length - 1; i >= 0; i++) {\r\n                const pos = toMounted[i]\r\n                const nextPos = pos + 1;\r\n                const curAnchor = (c2[nextPos] && (c2[nextPos] as any).elm) || anchor\r\n                patch(null, c2[pos], container, curAnchor)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/* 无 key 时 使用的 diff 算法 */\r\nfunction patchUnKeyedChildren(c1: [], c2: [], container: HTMLElement, anchor?: Text) {\r\n    const oldLength = c1.length\r\n    const newLength = c2.length\r\n    /* 选取最短的子数组 */\r\n    const commonLength = Math.min(oldLength, newLength)\r\n    /* 对比共同长度的子节点 */\r\n    for (let i = 0; i < commonLength; i++) {\r\n        patch(c1[i], c2[i], container, anchor)\r\n    }\r\n    /* 新孩子 多于 旧孩子 剩下部分 挂载孩子 */\r\n    if (newLength > oldLength) mountChildren(c2.slice(commonLength) as [], container, anchor)\r\n    /* 旧孩子 多于 新孩子 剩下部分 卸载孩子 */\r\n    if (newLength < oldLength) unmountChildren(c1.slice(commonLength) as [])\r\n\r\n}\r\n\r\nexport { patch, patchElement, patchProps, patchChildren }","import { vNode, ShapeFlags } from './utils'\r\n\r\n/* 卸载 vNode */\r\nfunction unmount(vNode: vNode) {\r\n    const { shapeFlag } = vNode\r\n    if (shapeFlag & ShapeFlags.COMPONENT) {\r\n        unmountComponent(vNode)\r\n    } else if (shapeFlag & ShapeFlags.FRAGMENT) {\r\n        unmountFragment(vNode)\r\n    } else {\r\n        unmountElementOrText(vNode)\r\n    }\r\n}\r\n\r\n/* 卸载组件 */\r\nfunction unmountComponent(vNode: vNode) {\r\n    unmount((vNode.component as any).subTree)\r\n}\r\n\r\n/* 卸载容器 */\r\nfunction unmountFragment(vNode: vNode) {\r\n    let { elm: cur, anchor: end } = vNode\r\n    const parentNode = cur!.parentNode\r\n    while (cur !== end) {\r\n        const next = cur!.nextSibling\r\n        parentNode!.removeChild(cur!);\r\n        (cur as any) = next\r\n    }\r\n    parentNode!.removeChild(end!)\r\n}\r\n\r\n/* 卸载元素或文本 */\r\nfunction unmountElementOrText(vNode: vNode) {\r\n    const { elm } = vNode\r\n    elm!.parentNode!.removeChild(elm as HTMLElement | Text)\r\n}\r\n\r\n/* 卸载孩子 */\r\nfunction unmountChildren(children: []) {\r\n    children.forEach(child => {\r\n        unmount(child)\r\n    })\r\n}\r\n\r\nexport { unmount, unmountChildren }","import { vNode } from './utils'\r\nimport { patch } from './patch'\r\nimport { unmount } from './unmount'\r\n\r\n/* 渲染函数 */\r\nfunction render(vNode: vNode | null, container: HTMLElement) {\r\n    const pervVNode = (container as any)._vNode\r\n    /*  判断是否传入新的vNode */\r\n    if (vNode) {\r\n        /* 进行 diff 算法 */\r\n        patch(pervVNode, vNode, container)\r\n    } else {\r\n        /* 没有传入新的 vNode 且有旧的 vNode 卸载旧 vNode */\r\n        if (pervVNode) unmount(pervVNode)\r\n    }\r\n    (container as any)._vNode = vNode\r\n}\r\n\r\nexport { render }","import { astContext } from './ast'\r\n\r\n/* HTML 标准元素 */\r\nconst HTML_TAGS =\r\n    'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot'\r\n\r\n/* HTML 标准自闭合元素 */\r\nconst VOID_TAGS =\r\n    'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\r\n\r\n/* 提供字符串生成判断函数 */\r\nfunction makeMap(str: string) {\r\n    const map = str.split(',').reduce((map, item) => ((map[item] = true), map), Object.create(null))\r\n    return (value: string) => !!map[value]\r\n}\r\n\r\n/* HTML 标准元素 判断函数 */\r\nexport const isNativeTag = makeMap(HTML_TAGS);\r\n\r\n/* HTML 标准自闭合元素 判断函数 */\r\nexport const isVoidTag = makeMap(VOID_TAGS);\r\n\r\n/* 删除指定长度内容 */\r\nexport function advanceBy(context: astContext, numberOfCharacters: number) {\r\n    const { source } = context\r\n    context.source = source.slice(numberOfCharacters)\r\n}\r\n\r\n/* 删除空格 */\r\nexport function advanceSpaces(context: astContext) {\r\n    const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\r\n    match && advanceBy(context, match![0].length)\r\n}\r\n\r\n/* 判断是否解析完成 */\r\nexport function isEnd(context: astContext) {\r\n    const template = context.source\r\n    return !template || template.startsWith('</')\r\n}\r\n\r\n/* 截取文本数据返回 并删除模板内对应数据 */\r\nexport function textData(context: astContext, length: number) {\r\n    const text = context.source.slice(0, length)\r\n    advanceBy(context, length)\r\n    return text\r\n}\r\n\r\n/* my-class 变 驼峰 myClass */\r\nexport function camelize(str: string) {\r\n    return str.replace(/-(\\w)/g, (_, c) => (c ? c.toUpperCase() : ''))\r\n}","import { isNativeTag, isVoidTag } from './utils'\r\n\r\n/* 节点类型 */\r\nenum NodeTypes {\r\n    /* 根节点 */\r\n    ROOT = 'ROOT',\r\n    /* 元素节点 */\r\n    ELEMENT = 'ELEMENT',\r\n    /* 文本节点 */\r\n    TEXT = 'TEXT',\r\n    /* 表达式节点 */\r\n    SIMPLE_EXPRESSION = 'SIMPLE_EXPRESSION',\r\n    /* 插值节点 */\r\n    INTERPOLATION = 'INTERPOLATION',\r\n    /* 属性节点 */\r\n    ATTRIBUTE = 'ATTRIBUTE',\r\n    /* 指令节点 */\r\n    DIRECTIVE = 'DIRECTIVE'\r\n}\r\n\r\n/* 元素类型 */\r\nenum ElementTypes {\r\n    /* 元素 */\r\n    ELEMENT = 'ELEMENT',\r\n    /* 组件 */\r\n    COMPONENT = 'COMPONENT'\r\n}\r\n\r\n/* 模板上下文 类型 */\r\ntype astContext = {\r\n    options: {\r\n        delimiters: string[];\r\n        isNativeTag: (value: string) => boolean;\r\n        isVoidTag: (value: string) => boolean;\r\n    };\r\n    source: string;\r\n}\r\n\r\n/* 创建解析模板上下文 */\r\nfunction createParserContext(template: string): astContext {\r\n    return {\r\n        options: {\r\n            delimiters: ['{{', '}}'],\r\n            isNativeTag,\r\n            isVoidTag\r\n        },\r\n        source: template\r\n    }\r\n}\r\n\r\n/* 创建 root 节点 */\r\nfunction createRoot(children: any) {\r\n    return {\r\n        type: NodeTypes.ROOT,\r\n        children,\r\n    }\r\n}\r\n\r\nexport { createParserContext, createRoot, astContext, NodeTypes, ElementTypes }","import { advanceBy, isEnd, textData, advanceSpaces, camelize } from './utils'\r\nimport { createRoot, createParserContext, astContext, NodeTypes, ElementTypes } from './ast'\r\n\r\n/* 模板解析器 */\r\nfunction parse(template: string) {\r\n    const context = createParserContext(template)\r\n    return createRoot(parseChildren(context))\r\n}\r\n\r\n/* 解析孩子 */\r\nfunction parseChildren(context: astContext) {\r\n    const nodes = []\r\n\r\n    while (!isEnd(context)) {\r\n        const template = context.source\r\n        let node: any\r\n        /* 开头是否是 插值标识符 */\r\n        if (template.startsWith(context.options.delimiters[0])) {\r\n            node = parseInterpolation(context)\r\n\r\n            /* 开头是否是 < */\r\n        } else if (template.startsWith('<')) {\r\n            node = parseElement(context)\r\n\r\n            /* 文本节点 */\r\n        } else {\r\n            node = parseText(context)\r\n        }\r\n        nodes.push(node)\r\n    }\r\n\r\n    /* 优化 空格 和 换行 */\r\n    /* 是否删除文本节点开关 */\r\n    let removedWhitespace = false;\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i]\r\n        /* 判断是否是文本节点 */\r\n        if (node.type === NodeTypes.TEXT) {\r\n            /* 判断是否此文本节点为空 */\r\n            if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n                const prev = nodes[i - 1]\r\n                const next = nodes[i + 1]\r\n                /* 前一个节点为空 或 后一个节点为空 或 前后都是元素节点且本节点有换行符 则删除本节点 否则 压缩空格 */\r\n                if (!prev || !next || (prev.type === NodeTypes.ELEMENT && next.type === NodeTypes.ELEMENT && /[\\r\\n]/.test(node.content))) {\r\n                    removedWhitespace = true\r\n                    nodes[i] = null\r\n                } else {\r\n                    node.content = ' '\r\n                }\r\n            } else {\r\n                /* 不为空 压缩空格 */\r\n                node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ')\r\n            }\r\n        }\r\n    }\r\n    return removedWhitespace ? nodes.filter(Boolean) : nodes\r\n}\r\n\r\n/* 解析插值语法 */\r\nfunction parseInterpolation(context: astContext) {\r\n    /* 拿出插值标识符 */\r\n    const [open, close] = context.options.delimiters\r\n    /* 删除左插值符 */\r\n    advanceBy(context, open.length)\r\n    /* 取出内容并删除模板内对应数据 */\r\n    const closeIndex = context.source.indexOf(close)\r\n    const content = textData(context, closeIndex).trim()\r\n    /* 删除右插值符 */\r\n    advanceBy(context, close.length)\r\n\r\n    return {\r\n        type: NodeTypes.INTERPOLATION,\r\n        content: {\r\n            type: NodeTypes.SIMPLE_EXPRESSION,\r\n            content,\r\n            isStatic: false,\r\n        }\r\n    }\r\n}\r\n\r\n/* 解析元素 */\r\nfunction parseElement(context: astContext) {\r\n    /* 解析元素 */\r\n    const element: any = parseTag(context)\r\n    /* 如果是自闭合标签 直接返回 */\r\n    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) return element\r\n    /* 解析孩子 */\r\n    element.children = parseChildren(context)\r\n    /* 解析结束标签 但是不做收集 */\r\n    parseTag(context)\r\n\r\n    return element\r\n}\r\n\r\n/* 解析元素标签 */\r\nfunction parseTag(context: astContext) {\r\n    const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)\r\n    /* 读取元素标签 */\r\n    const tag = match![1]\r\n    /* 删除 标签 接下来的空格 */\r\n    advanceBy(context, match![0].length)\r\n    advanceSpaces(context)\r\n    /* 获取标签类型 原生 还是 组件 */\r\n    const tagType = context.options.isNativeTag(tag) ? ElementTypes.ELEMENT : ElementTypes.COMPONENT\r\n    /* 解析 属性 和 指令 */\r\n    const { props, directives } = parseAttributes(context)\r\n    /* 判断是否是自闭合标签 */\r\n    const isSelfClosing = context.source.startsWith('/>')\r\n    /* 删除结束 > 或者 /> */\r\n    advanceBy(context, isSelfClosing ? 2 : 1)\r\n\r\n    return {\r\n        type: NodeTypes.ELEMENT,\r\n        tag,\r\n        tagType,\r\n        props,\r\n        directives,\r\n        isSelfClosing,\r\n        children: [],\r\n    }\r\n}\r\n\r\n/* 解析元素标签属性 */\r\nfunction parseAttributes(context: astContext) {\r\n    const props: any = [], directives: any = []\r\n    /* 解析 属性 合 指令 */\r\n    while (context.source.length && !context.source.startsWith('>') && !context.source.startsWith('/>')) {\r\n        let attr = parseAttribute(context)\r\n        attr.type === NodeTypes.DIRECTIVE ? directives.push(attr) : props.push(attr)\r\n    }\r\n    return { props, directives }\r\n}\r\n\r\n/* 解析单个属性 */\r\nfunction parseAttribute(context: astContext) {\r\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)\r\n    /* 获取 属性 活 指令 名 */\r\n    const name = match![0]\r\n    advanceBy(context, name.length)\r\n    advanceSpaces(context)\r\n\r\n    /* 获取 属性 或 指令 对应的值 */\r\n    let content: any\r\n    if (context.source[0] === '=') {\r\n        advanceBy(context, 1)\r\n        advanceSpaces(context)\r\n        content = parseAttributeValue(context)\r\n        advanceSpaces(context)\r\n    }\r\n\r\n    /* 是否是 指令 */\r\n    if (/^(r-|@|:)/.test(name)) {\r\n        let dirName: any, argContent: any\r\n\r\n        if (name[0] === ':') {\r\n            dirName = 'bind'\r\n            argContent = name.slice(1)\r\n        }\r\n\r\n        if (name[0] === '@') {\r\n            dirName = 'on'\r\n            argContent = name.slice(1)\r\n        }\r\n\r\n        if (name.startsWith('r-')) {\r\n            [dirName, argContent] = name.slice(2).split(':')\r\n        }\r\n\r\n        /* 返回 指令 */\r\n        return {\r\n            type: NodeTypes.DIRECTIVE,\r\n            name: dirName,\r\n            arg: argContent && {\r\n                type: NodeTypes.SIMPLE_EXPRESSION,\r\n                content: camelize(argContent),\r\n                isStatic: true,\r\n            },\r\n            exp: content && {\r\n                type: NodeTypes.SIMPLE_EXPRESSION,\r\n                content: content,\r\n                isStatic: false,\r\n            }\r\n        }\r\n    }\r\n\r\n    /* 返回 属性 */\r\n    return {\r\n        type: NodeTypes.ATTRIBUTE,\r\n        name,\r\n        value: content && {\r\n            type: NodeTypes.TEXT,\r\n            content: content,\r\n        }\r\n    }\r\n}\r\n\r\n/* 解析单个属性对应的值 */\r\nfunction parseAttributeValue(context: astContext) {\r\n    /* 获取是 单引号 还是 双引号 */\r\n    const quote = context.source[0]\r\n    advanceBy(context, 1)\r\n    const endIndex = context.source.indexOf(quote)\r\n    /* 获取内容 */\r\n    const content = textData(context, endIndex)\r\n    advanceBy(context, 1)\r\n\r\n    return content\r\n}\r\n\r\n/* 解析文本 */\r\nfunction parseText(context: astContext) {\r\n    const { delimiters } = context.options\r\n    /* < < > 判断正则 */\r\n    const lessRegexp = /\\<[^\\<\\>]+(\\<[^\\<\\>]+\\>)/\r\n    /* 插值 {{ {{ }} 判断正则 */\r\n    const interpolation = new RegExp(`${delimiters[0]}[^${delimiters[0]}${delimiters[1]}]+(${delimiters[0]}[^${delimiters[0]}${delimiters[1]}]+${delimiters[1]})`)\r\n    /* 结束长度 */\r\n    let endIndex = context.source.length\r\n\r\n    /* \r\n        判断 文本节点中是否带 < \r\n        如果有 就找最先满足 < > 的位置\r\n        没有 就直接找最先的 < \r\n    */\r\n    /* 对比是否小于 结束长度 并替换 */\r\n    if (lessRegexp.test(context.source)) {\r\n        const index = context.source.indexOf(lessRegexp.exec(context.source)![1])\r\n        if (index !== -1 && endIndex > index) endIndex = index\r\n    } else {\r\n        const index = context.source.indexOf('<')\r\n        if (index !== -1 && endIndex > index) endIndex = index\r\n    }\r\n\r\n    /* \r\n        判断 文本节点中是否带 左插值 \r\n        如果有 就找最先满足 完整插值 的位置 \r\n        没有 就直接找最先的 左插值 \r\n    */\r\n    /* 对比是否小于 结束长度 并替换 */\r\n    if (interpolation.test(context.source)) {\r\n        const index = context.source.indexOf(interpolation.exec(context.source)![1])\r\n        if (index !== -1 && endIndex > index) endIndex = index\r\n    } else {\r\n        const index = context.source.indexOf(delimiters[0])\r\n        if (index !== -1 && endIndex > index) endIndex = index\r\n    }\r\n    const content = textData(context, endIndex)\r\n\r\n    return {\r\n        type: NodeTypes.TEXT,\r\n        content\r\n    }\r\n}\r\n\r\nexport { parse }","import { NodeTypes } from '../compiler/ast'\r\nimport { createText, resolveElementASTNode, createTextVNode } from './codegen'\r\nimport { capitalize } from './utils'\r\n\r\n/* 解析 普通指令 */\r\nfunction createDirectives(directives: any, node: any): any[] {\r\n    const resultDirectives = directives.map((directive: any) => {\r\n        switch (directive.name) {\r\n            case 'bind':\r\n                return `${directive.arg.content}: ${createText(directive.exp)}`\r\n            case 'on':\r\n                let exp = directive.exp.content\r\n                let result = directive.exp.content\r\n                /* 支持 加减乘除 简单运算表达式 */\r\n                if (/(\\+|\\-|\\*|\\/)/.test(exp) && !exp.includes('=>') && !exp.includes('function')) result = `$event => (${exp})`\r\n\r\n                /* 支持传递参数版本 */\r\n                if (/\\([^\\)]*?\\)$/.test(exp)) if (!/^(\\$event)/.test(result)) result = `$event => (${exp})`\r\n\r\n                return `on${capitalize(directive.arg.content)}: ${result}`\r\n            default:\r\n                return `${directive.name}: ${createText(directive.exp)}`\r\n        }\r\n    })\r\n    return resultDirectives\r\n}\r\n\r\n/* 解析 特殊指令 */\r\n/* 解析 if else-if else */\r\nfunction directiveIf(ifNode: any, node: any, parent: any): any {\r\n    const { exp } = ifNode\r\n    /* if */\r\n    const consequent: any = resolveElementASTNode(node, parent)\r\n    /* else */\r\n    let alternate: any\r\n    const { children } = parent\r\n    /* 寻找 else-if else */\r\n    let index = children.findIndex((child: any) => child === node) + 1\r\n    for (let i = index; i < children.length; i++) {\r\n        /* 获取当前 node */\r\n        const sibling = children[i]\r\n        /* 删除 空白 文本节点 */\r\n        if (sibling.type === NodeTypes.TEXT && !sibling.content.trim()) {\r\n            children.splice(i, 1)\r\n            i--\r\n            continue\r\n        }\r\n        /* 解析 else-if else */\r\n        if (sibling.type === NodeTypes.ELEMENT && (pluck(sibling.directives, 'else') || pluck(sibling.directives, 'else-if', false))) {\r\n            alternate = resolveElementASTNode(sibling, parent)\r\n            children.splice(i, 1)\r\n        }\r\n        break\r\n    }\r\n    return `${exp.content} ? ${consequent} : ${alternate || createTextVNode()}`\r\n}\r\n\r\n/* 解析 for */\r\nfunction directiveFor(forNode: any, node: any): any {\r\n    const { exp } = forNode\r\n    /* 允许 in of */\r\n    const [args, source] = exp.content.split(/\\sin\\s|\\sof\\s/)\r\n    return `h(Fragment, null, renderList(${source.trim()}, ${args.trim()} => ${resolveElementASTNode(node)}))`\r\n}\r\n\r\n/* 解析 model */\r\nfunction directiveModel(modelNode: any, node: any): any {\r\n    node.directives.push(\r\n        {\r\n            type: NodeTypes.DIRECTIVE,\r\n            name: 'bind',\r\n            exp: modelNode.exp,\r\n            arg: {\r\n                type: NodeTypes.SIMPLE_EXPRESSION,\r\n                content: 'value',\r\n                isStatic: true,\r\n            },\r\n        },\r\n        {\r\n            type: NodeTypes.DIRECTIVE,\r\n            name: 'on',\r\n            exp: {\r\n                type: NodeTypes.SIMPLE_EXPRESSION,\r\n                content: `($event) => ${modelNode.exp.content} = $event.target.value`,\r\n                isStatic: false,\r\n            },\r\n            arg: {\r\n                type: NodeTypes.SIMPLE_EXPRESSION,\r\n                content: 'input',\r\n                isStatic: true,\r\n            },\r\n        }\r\n    )\r\n}\r\n\r\n/* 查找特殊指令 并 返回 且 决定是否 删除 */\r\nfunction pluck(directives: any[], name: string, remove: boolean = true) {\r\n    const index = directives.findIndex(directive => directive.name === name)\r\n    const directive = directives[index]\r\n    if (index > -1 && remove) directives.splice(index, 1)\r\n    return directive\r\n}\r\n\r\nexport { createDirectives, pluck, directiveIf, directiveFor, directiveModel }","/* 首字母大写 */\r\nexport function capitalize(str: string) {\r\n    return str[0].toUpperCase() + str.slice(1)\r\n}","import { NodeTypes, ElementTypes } from '../compiler/ast'\r\nimport { createDirectives, pluck, directiveIf, directiveFor, directiveModel } from './directives'\r\n\r\n/* 生成 render 渲染函数 */\r\nfunction generate(ast: any) {\r\n    return `\r\n    const { h, Text, Fragment, renderList, resolveComponent } = rainCore\r\n        with(ctx) {\r\n            return ${traverseNode(ast)}\r\n        }\r\n   `\r\n}\r\n\r\n/* 解析 ast 和 指令 生成 渲染函数 */\r\nfunction traverseNode(node: any, parent?: any) {\r\n    switch (node.type) {\r\n        case NodeTypes.ROOT:\r\n            return createChildrenVNode(node)\r\n        case NodeTypes.ELEMENT:\r\n            return resolveElementASTNode(node, parent)\r\n        case NodeTypes.INTERPOLATION:\r\n            return createInterpolationVNode(node)\r\n        case NodeTypes.TEXT:\r\n            return createTextVNode(node)\r\n    }\r\n}\r\n\r\n/* 处理 特殊指令 */\r\nfunction resolveElementASTNode(node: any, parent?: any) {\r\n    /* 解析 if else-if else */\r\n    const ifNode = pluck(node.directives, 'if') || pluck(node.directives, 'else-if')\r\n    if (ifNode) return directiveIf(ifNode, node, parent)\r\n    /* 解析 model */\r\n    const modelNode = pluck(node.directives, 'model')\r\n    if (modelNode) directiveModel(modelNode, node)\r\n    /* 解析 for */\r\n    const forNode = pluck(node.directives, 'for')\r\n    if (forNode) return directiveFor(forNode, node)\r\n\r\n    return createElementVNode(node)\r\n}\r\n\r\n\r\n/* 生成元素节点 渲染函数 */\r\nfunction createElementVNode(node: any) {\r\n    /* 获取标签名 */\r\n    const tag = node.tagType === ElementTypes.ELEMENT ? `\"${node.tag}\"` : `resolveComponent(\"${node.tag}\")`\r\n\r\n    /* 解析属性和指令 */\r\n    const propsArr = createPropsArr(node)\r\n    const props = propsArr.length ? `{ ${propsArr.join(', ')} }` : null\r\n    /* 解析孩子 */\r\n    const children = node.children.length ? createChildrenVNode(node) : null\r\n    return `h(${tag}, ${props}, ${children})`\r\n}\r\n\r\n/* 解析 属性 和 指令 */\r\nfunction createPropsArr(node: any) {\r\n    const { props, directives } = node\r\n    return [\r\n        /* 解析 属性 */\r\n        ...props.map((prop: any) => `${prop.name}: ${createText(prop.value)}`),\r\n        /* 解析指令 */\r\n        ...createDirectives(directives, node)\r\n    ]\r\n}\r\n\r\n/* 生成孩子节点 渲染函数 */\r\nfunction createChildrenVNode(node: any): string {\r\n    const { children } = node\r\n    const result = []\r\n    for (let i = 0; i < children.length; i++) {\r\n        result.push(traverseNode(children[i], node))\r\n    }\r\n    return `[${result.join(', ')}]`\r\n}\r\n\r\n/* 生成插值节点 渲染函数 */\r\nfunction createInterpolationVNode(node: any) {\r\n    return `h(Text, null, ${createText(node.content)})`\r\n}\r\n\r\n/* 生成文本节点 渲染函数 */\r\nfunction createTextVNode(node?: any) {\r\n    return `h(Text, null, ${createText(node)})`\r\n}\r\n\r\n/* 生成 静态文本 还是 表达式 */\r\nfunction createText({ isStatic = true, content = '' } = {}) {\r\n    return isStatic ? JSON.stringify(content) : content\r\n}\r\n\r\nexport { generate, createText, resolveElementASTNode, createTextVNode }","import { parse } from '../compiler/index'\r\nimport { generate } from './codegen'\r\n\r\n/* 解析 模板 并 转换成 render 渲染函数 */\r\nfunction compile(template: string) {\r\n    const ast = parse(template)\r\n    return generate(ast)\r\n}\r\n\r\nexport { compile }","import { isString } from '../runtime/utils'\r\nimport { h } from '../runtime/vnode'\r\nimport { render } from '../runtime/render'\r\nimport { compile } from './compile'\r\n\r\nlet components: any\r\n\r\nfunction createApp(component: any) {\r\n    /* 注册组件 */\r\n    components = component.components || {}\r\n\r\n    /* 不写渲染函数形式 且 有模板 */\r\n    if (!component.render && component.template) {\r\n        if (component.template[0] === '#') {\r\n            const el = document.querySelector(component.template)\r\n            el ? component.template = el.innerHTML : ''\r\n        }\r\n        component.render = new Function('ctx', compile(component.template)!)\r\n    }\r\n\r\n    return {\r\n        mount(container: any) {\r\n            /* 获取挂载点 */\r\n            if (isString(container)) container = document.querySelector(container as string)\r\n            /* 不写渲染函数形式 且 不写模板 */\r\n            if (!component.render && !component.template) {\r\n                component.template = container.innerHTML\r\n                component.render = new Function('ctx', compile(component.template)!)\r\n                container.innerHTML = ''\r\n            }\r\n            render(h(component, null, null), container)\r\n        }\r\n    }\r\n}\r\n\r\nfunction resolveComponent(name: string) {\r\n    let component: any\r\n    /* 傻逼浏览器乱弄大小写 */\r\n    Object.keys(components).findIndex(key => {\r\n        if (key.toLowerCase() === name.toLowerCase()) component = components[key]\r\n    })\r\n\r\n    if (!component.render && component.template) {\r\n        if (component.template[0] === '#') {\r\n            const el = document.querySelector(component.template)\r\n            el ? component.template = el.innerHTML : ''\r\n        }\r\n        component.render = new Function('ctx', compile(component.template)!)\r\n    }\r\n\r\n    return component\r\n}\r\n\r\nexport { createApp, resolveComponent }","import { isArray, isNumber, isObject, isString } from './utils'\r\nfunction renderList(source: any, renderItem: Function) {\r\n    const nodes: any = []\r\n    /* 传入值为 数字 */\r\n    if (isNumber(source)) {\r\n        for (let i = 0; i < source; i++) {\r\n            nodes.push(renderItem(i + 1, i))\r\n        }\r\n        return nodes\r\n    }\r\n    /* 传入值为 数组 或 字符串 */\r\n    if (isArray(source) || isString(source)) {\r\n        for (let i = 0; i < source.length; i++) {\r\n            nodes.push(renderItem(source[i], i))\r\n        }\r\n        return nodes\r\n    }\r\n    /* 传入值为 对象 */\r\n    if (isObject(source)) {\r\n        const keys = Object.keys(source)\r\n        keys.forEach((key, index) => {\r\n            nodes.push(renderItem(source[key], key, index))\r\n        })\r\n        return nodes\r\n    }\r\n\r\n    return nodes\r\n}\r\n\r\nexport { renderList }","import { isRef } from './utils'\r\nimport { effect } from './effect'\r\n\r\nfunction watch(getter: any, func: Function): Function {\r\n    let _value = isRef(getter) ? getter.value : getter()\r\n\r\n    let effectFn: any = effect(() => isRef(getter) ? getter.value : getter(), {\r\n        scheduler: (effect: any, value: any) => {\r\n            func(value, _value)\r\n            _value = value\r\n        }\r\n    })\r\n    const deps = effectFn.deps\r\n    return function () {\r\n        deps.delete(effectFn)\r\n        effectFn = null\r\n        _value = null\r\n    }\r\n}\r\n\r\nexport { watch }","import { effect } from './effect'\r\n\r\n/* 返回一个函数 调用 停止监听 */\r\nfunction watchEffect(func: Function): Function {\r\n    let effectFn: any = effect(func)\r\n    const deps = effectFn.deps\r\n    return function () {\r\n        deps.delete(effectFn)\r\n        effectFn = null\r\n    }\r\n}\r\n\r\nexport { watchEffect }"],"names":["IS_REACTIVE","RAW","isObject","target","isReactive","isRef","value","hasChanged","oldValue","newValue","Number","isNaN","effectStack","activeEffect","effect","func","options","effectFn","push","pop","length","lazy","scheduler","targetMap","WeakMap","track","key","depsMap","get","set","Map","deps","Set","add","trigger","forEach","reactiveMap","reactive","has","raw","proxy","Proxy","receiver","result","Reflect","oldLength","Array","isArray","createReactiveObject","refImpl","constructor","__isRef","__rawValue","_value","convert","this","ComputedRefImpl","getter","setter","_setter","undefined","_dirty","ShapeFlags","Text","Symbol","Fragment","isString","isNumber","domPropsRE","h","type","props","children","shapeFlag","vNodeType","toString","elm","anchor","component","normalizeVNode","initProps","instance","vNode","Component","vNodeProps","attrs","includes","fallThrough","subTree","Object","keys","queue","isFlushing","resolePromise","Promise","resolve","queueJob","job","then","flushJobs","i","mountChildren","container","child","patch","processComponent","n1","n2","next","update","updateComponent","setupState","ctx","isMounted","setup","prev","render","mountComponent","processText","textContent","textNode","document","createTextNode","insertBefore","mountTextNode","processElement","patchProps","patchChildren","patchElement","el","createElement","mountElement","unmount","unmountComponent","cur","end","parentNode","nextSibling","removeChild","unmountFragment","unmountElementOrText","unmountChildren","isSameVNode","fragmentStartAnchor","fragmentEndAnchor","processFragment","oldProps","newProps","patchDomProp","temp","trim","className","str","split","item","styleName","style","removeAttribute","test","eventName","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","prevShapeFlag","c1","c2","c1True","c2True","c","isChildrenKey","start","e1","e2","nextPos","curAnchor","map","index","maxNewIndexSoFar","move","toMounted","sources","fill","delete","_ref","sequence","numberArray","position","l","r","mid","getSequence","pos","patchKeyedChildren","newLength","commonLength","Math","min","patchUnKeyedChildren","pervVNode","_vNode","makeMap","reduce","create","isNativeTag","isVoidTag","advanceBy","context","numberOfCharacters","source","advanceSpaces","match","exec","isEnd","template","startsWith","textData","text","NodeTypes","ElementTypes","parse","delimiters","createParserContext","parseChildren","ROOT","nodes","node","parseInterpolation","parseElement","parseText","removedWhitespace","TEXT","content","replace","ELEMENT","filter","Boolean","open","close","closeIndex","indexOf","INTERPOLATION","SIMPLE_EXPRESSION","isStatic","element","parseTag","isSelfClosing","tag","tagType","COMPONENT","directives","attr","parseAttribute","DIRECTIVE","parseAttributes","name","quote","endIndex","parseAttributeValue","dirName","argContent","arg","_","toUpperCase","exp","ATTRIBUTE","lessRegexp","interpolation","RegExp","createDirectives","directive","createText","pluck","remove","findIndex","splice","traverseNode","parent","createChildrenVNode","resolveElementASTNode","createInterpolationVNode","createTextVNode","ifNode","consequent","alternate","sibling","directiveIf","modelNode","directiveModel","forNode","args","directiveFor","propsArr","prop","createPropsArr","join","createElementVNode","JSON","stringify","compile","ast","generate","components","getterOrOptions","console","warn","querySelector","innerHTML","Function","mount","renderItem","ref"],"mappings":"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"}