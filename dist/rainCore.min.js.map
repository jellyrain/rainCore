{"version":3,"file":"rainCore.min.js","sources":["../src/reactivity/utils.ts","../src/reactivity/effect.ts","../src/reactivity/reactive.ts","../src/reactivity/ref.ts","../src/reactivity/computed.ts","../src/runtime/utils.ts","../src/runtime/mount.ts","../src/runtime/process.ts","../src/runtime/patch.ts","../src/runtime/unmount.ts","../src/runtime/vnode.ts","../src/runtime/render.ts","../src/reactivity/watch.ts","../src/reactivity/watchEffect.ts"],"sourcesContent":["/* reactive 响应式标识 */\r\nexport const IS_REACTIVE: string = '__isReactive'\r\n/* reactive 响应式标识 */\r\nexport const IS_REF: string = '__isRef'\r\n/* 代理前对象标识 */\r\nexport const RAW: string = '__raw'\r\n\r\n/* 判断是否是对象 */\r\nexport function isObject(target: any) {\r\n    return typeof target === 'object' && target != null\r\n}\r\n\r\n/* 判断是否是数组 */\r\nexport function isArray(target: any) {\r\n    return Array.isArray(target)\r\n}\r\n\r\n/* 判断是否是函数 */\r\nexport function isFunction(target: any) {\r\n    return typeof target === 'function' && target != null\r\n}\r\n\r\n/* 判断是否是 reactive 响应式对象 */\r\nexport function isReactive(target: any) {\r\n    return !!(target && target[IS_REACTIVE])\r\n\r\n}\r\n\r\n/* 判断是否是 ref 响应式对象 */\r\nexport function isRef(value: any) {\r\n    return !!(value && value[IS_REF])\r\n}\r\n\r\n/* 判断两个值是否一致 */\r\nexport function hasChanged(oldValue: any, newValue: any) {\r\n    return oldValue !== newValue && !(Number.isNaN(oldValue) || Number.isNaN(newValue))\r\n}","const effectStack: any = []\r\n/* 暴露依赖 */\r\nlet activeEffect: any\r\n\r\nfunction effect(func: Function, options: any = {}): Function {\r\n    const effectFn = () => {\r\n        try {\r\n            effectStack.push(effectFn)\r\n            activeEffect = effectFn\r\n            return func()\r\n        } finally {\r\n            effectStack.pop()\r\n            activeEffect = effectStack[effectStack.length - 1]\r\n        }\r\n    }\r\n    /* 是否先执行一次 */\r\n    if (!options.lazy) effectFn()\r\n\r\n    effectFn.scheduler = options.scheduler\r\n\r\n    return effectFn\r\n}\r\n\r\n/* 收集依赖 */\r\nconst targetMap: WeakMap<object, any> = new WeakMap()\r\n\r\nfunction track(target: any, key: string | symbol): void {\r\n    /* 是否有依赖需要收集 没有直接发返回 */\r\n    if (!activeEffect) return\r\n    /* \r\n        查找是否有此响应式数据对应的依赖组 \r\n        如果没有为该数据创建 Map \r\n    */\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) targetMap.set(target, (depsMap = new Map()))\r\n    /* \r\n        查找是否有此响应式数据内数据的依赖组 \r\n        如果没有为该数据创建 Set \r\n    */\r\n    let deps = depsMap.get(key)\r\n    if (!deps) depsMap.set(key, (deps = new Set()))\r\n    /* 把用到此数据的依赖挂载到 effectFn 上 提供删除 */\r\n    activeEffect.deps = deps\r\n    /* 添加依赖 */\r\n    deps.add(activeEffect)\r\n}\r\n\r\n/* 触发依赖 */\r\nfunction trigger(target: any, key: string | symbol, value?: any): void {\r\n    const depsMap = targetMap.get(target)\r\n    /* \r\n        查找是否有此响应式数据对应的依赖组 \r\n        没有就直接返回\r\n    */\r\n    if (!depsMap) return\r\n    /* \r\n       查找是否有此响应式数据内数据的依赖组 \r\n       没有就直接返回\r\n    */\r\n    const deps = depsMap.get(key)\r\n    if (!deps) return\r\n    /* 触发依赖 */\r\n    deps.forEach((effect: { (): any; scheduler: (effect: any, value: any) => any }) => {\r\n        /* 有调度 scheduler 优先触发 scheduler */\r\n        effect.scheduler ? effect.scheduler(effect, value) : effect()\r\n    })\r\n}\r\n\r\nexport { effect, track, trigger, targetMap }","import { IS_REACTIVE, RAW, isObject, isArray, isReactive, hasChanged } from './utils'\r\nimport { track, trigger } from './effect'\r\n\r\n/* 保存响应式对象 */\r\nconst reactiveMap = new WeakMap()\r\n\r\nfunction reactive(target: any) {\r\n    /* 如果不是对象直接返回 */\r\n    if (!isObject(target)) return target\r\n    /* 是否已经是响应式对象 如果是直接返回 */\r\n    if (isReactive(target)) return target\r\n    /* 如果对象已经做过响应式 就直接返沪响应式对象 */\r\n    if (reactiveMap.has(target)) return reactiveMap.get(target)\r\n    /* 创建响应式对象 */\r\n    return createReactiveObject(target)\r\n}\r\n\r\n/* 提供一个响应式对象，返回原始对象 */\r\nfunction toRaw(target: any) {\r\n    if (isReactive(target)) return target[RAW]\r\n}\r\n\r\nfunction createReactiveObject(target: any) {\r\n    const raw = target\r\n    const proxy: any = new Proxy(target, {\r\n        get(target, key, receiver) {\r\n            /* 判断是否是响应式对象 */\r\n            if (key === IS_REACTIVE) return true\r\n            /* 获取原对象 */\r\n            if (key === RAW) return raw\r\n\r\n            const result = Reflect.get(target, key, receiver)\r\n            /* 收集依赖 */\r\n            track(target, key)\r\n            /* 返回值 */\r\n            return isObject(result) ? reactive(result) : result\r\n        },\r\n        set(target, key, value, receiver) {\r\n            /* 获取旧值 */\r\n            const oldValue = target[key]\r\n            const oldLength = target.length\r\n\r\n            const result = Reflect.set(target, key, value, receiver)\r\n            /* 判断新值和旧值是否不一样 */\r\n            if (hasChanged(oldValue, value)) {\r\n                /* 触发依赖 */\r\n                trigger(target, key, value)\r\n                /* 如果是数组 判断是否依赖长度 是 判断是否改变 改变触发依赖 */\r\n                if (isArray(target) && target.length !== oldLength) trigger(target, 'length')\r\n            }\r\n            return result\r\n        }\r\n    })\r\n    /* 添加记录 */\r\n    reactiveMap.set(target, proxy)\r\n    return proxy\r\n}\r\n\r\nexport { reactive, toRaw }","import { isObject, isRef, hasChanged } from './utils'\r\nimport { reactive } from './reactive'\r\nimport { track, trigger } from './effect'\r\n\r\nfunction ref(value: any) {\r\n    /* 是否已经是响应式对象 如果是直接返回 */\r\n    if (isRef(value)) return value\r\n    /* 创建响应式对象 */\r\n    return new refImpl(value)\r\n}\r\n\r\nclass refImpl {\r\n    private __rawValue: any\r\n    private __isRef: boolean\r\n    private _value: any\r\n    /* \r\n        都是基础类型  __rawValue 和 _value 相等\r\n        如果是对象 \r\n            __rawValue：原始对象\r\n            _value：响应式对象\r\n    */\r\n    constructor(value: any) {\r\n        this.__isRef = true\r\n        this.__rawValue = value\r\n        this._value = convert(value)\r\n    }\r\n\r\n    get value() {\r\n        /* 收集依赖 */\r\n        track(this, 'value')\r\n        /* 返回值 */\r\n        return this._value\r\n    }\r\n\r\n    set value(value) {\r\n        if (hasChanged(this._value, value)) {\r\n            /* 更新数据 */\r\n            this._value = convert(value)\r\n            this.__rawValue = value\r\n            /* 触发依赖 */\r\n            trigger(this, 'value', value)\r\n        }\r\n    }\r\n}\r\n\r\nfunction convert(value: any) {\r\n    return isObject(value) ? reactive(value) : value\r\n}\r\n\r\n/* 自动判断是否是 ref 并且获取值 不是 旧返回参数 */\r\nfunction unRef(ref: any) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\n\r\nexport { ref, unRef }","import { track, trigger, effect } from './effect'\r\nimport { isFunction } from './utils'\r\n\r\nfunction computed(getterOrOptions: any): ComputedRefImpl {\r\n    let getter, setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions\r\n        setter = () => {\r\n            console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n    } else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter)\r\n}\r\n\r\nclass ComputedRefImpl {\r\n    private _setter: Function\r\n    private _value: any\r\n    private _dirty: boolean\r\n    private effect: any\r\n    constructor(getter: Function, setter: Function) {\r\n        this._setter = setter\r\n        /* 缓存结果 */\r\n        this._value = undefined\r\n        /* 判断依赖值是否改变 */\r\n        this._dirty = true\r\n        /* 监听依赖变化 */\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true\r\n                    /* 触发依赖 */\r\n                    trigger(this, 'value', this._value)\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect()\r\n            this._dirty = false\r\n            /* 收集依赖 */\r\n            track(this, 'value')\r\n        }\r\n        return this._value\r\n    }\r\n\r\n    set value(value) {\r\n        this._setter(value)\r\n    }\r\n}\r\n\r\nexport { computed }","/* vNode 类型 */\r\nexport type vNode = {\r\n    /* 类型 */\r\n    type: string | Symbol | object,\r\n    /* 属性 */\r\n    props: object | null,\r\n    /* 孩子 */\r\n    children: string | number | [] | null,\r\n    /* 类型标签 */\r\n    shapeFlag: number,\r\n    /* DOM 节点 */\r\n    elm: HTMLElement | Text | null,\r\n    /* Fragment 专属属性 anchor */\r\n    anchor: Text | null,\r\n    /* key */\r\n    key: string | null\r\n}\r\n\r\n/* vNode 类型判断 使用位运算 可以提高效率 */\r\nexport const ShapeFlags = {\r\n    ELEMENT: 1, // 00000001 元素\r\n    TEXT: 1 << 1, // 00000010 文本\r\n    FRAGMENT: 1 << 2, // 00000100 容器\r\n    COMPONENT: 1 << 3, // 00001000 组件\r\n    TEXT_CHILDREN: 1 << 4, // 00010000 string 孩子\r\n    ARRAY_CHILDREN: 1 << 5, // 00100000 数组 孩子\r\n    CHILDREN: (1 << 4) | (1 << 5), //00110000 孩子\r\n}\r\n\r\n/* 文本唯一标识 */\r\nexport const Text = Symbol('Text')\r\n\r\n/* 容器唯一标识 */\r\nexport const Fragment = Symbol('Fragment')\r\n\r\n/* 判断是否是字符串 */\r\nexport function isString(target: any) {\r\n    return typeof target === 'string'\r\n}\r\n\r\n/* 判断是否是字符串 */\r\nexport function isNumber(target: any) {\r\n    return typeof target === 'number'\r\n}\r\n\r\n/* 判断是否是字符串 */\r\nexport function isArray(target: any) {\r\n    return Array.isArray(target)\r\n}\r\n\r\n/* 判断是否是同类型的vNode */\r\nexport function isSameVNode(n1: vNode, n2: vNode) {\r\n    return n1.type === n2.type\r\n}\r\n\r\n/* 判断孩子是否都有key */\r\nexport function isChildrenKey(c1: [], c2: []) {\r\n    let c1True = 0, c2True = 0\r\n    c1.forEach(c => {\r\n        if (c && c['key'] != null) c1True++\r\n    })\r\n    c2.forEach(c => {\r\n        if (c && c['key'] != null) c2True++\r\n    })\r\n    return c1True === c1.length && c2True === c2.length\r\n}\r\n\r\n/* 判断 vNode 类型 */\r\nexport function vNodeType(type: string | Symbol | object): number {\r\n    /* 判断是否是标签 */\r\n    if (isString(type)) return ShapeFlags.ELEMENT\r\n    /* 判断是否是文本 */\r\n    if (type === Text) return ShapeFlags.TEXT\r\n    /* 是否是容器 */\r\n    if (type === Fragment) return ShapeFlags.FRAGMENT\r\n    /* 是否是组件 */\r\n    return ShapeFlags.COMPONENT\r\n}\r\n\r\n/* dom 属性正则 */\r\nexport const domPropsRE = /[A-Z]|^(value|checked|selected|muted|disabled)$/\r\n\r\n/* 最长上升子序列算法 */\r\nexport function getSequence(numberArray: []) {\r\n    const result: any = [];\r\n    const position = [];\r\n    for (let i = 0; i < numberArray.length; i++) {\r\n        if (numberArray[i] === -1) {\r\n            continue;\r\n        }\r\n        // result[result.length - 1]可能为undefined，此时numberArray[i] > undefined为false\r\n        if (numberArray[i] > result[result.length - 1]) {\r\n            result.push(numberArray[i]);\r\n            position.push(result.length - 1);\r\n        } else {\r\n            let l = 0,\r\n                r = result.length - 1;\r\n            while (l <= r) {\r\n                const mid = ~~((l + r) / 2);\r\n                if (numberArray[i] > result[mid]) {\r\n                    l = mid + 1;\r\n                } else if (numberArray[i] < result[mid]) {\r\n                    r = mid - 1;\r\n                } else {\r\n                    l = mid;\r\n                    break;\r\n                }\r\n            }\r\n            result[l] = numberArray[i];\r\n            position.push(l);\r\n        }\r\n    }\r\n    let cur = result.length - 1;\r\n    for (let i = position.length - 1; i >= 0 && cur >= 0; i--) {\r\n        if (position[i] === cur) {\r\n            result[cur--] = i;\r\n        }\r\n    }\r\n    return result;\r\n}","import { vNode, ShapeFlags } from './utils'\r\nimport { patch, patchProps } from './patch'\r\n\r\n/* 挂载元素 */\r\nfunction mountElement(vNode: vNode, container: HTMLElement, anchor?: Text) {\r\n    const { type, props, shapeFlag, children } = vNode\r\n    const el = document.createElement(type as string)\r\n    if (props) patchProps(null, props, el)\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) el.textContent = vNode.children as string\r\n    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) mountChildren(children as [], el)\r\n    vNode.elm = el\r\n    container.insertBefore(el, anchor as Text)\r\n}\r\n\r\n/* 挂载文本 */\r\nfunction mountTextNode(vNode: vNode, container: HTMLElement, anchor?: Text) {\r\n    const textNode = document.createTextNode(vNode.children as string)\r\n    vNode.elm = textNode\r\n    container.insertBefore(textNode, anchor as Text)\r\n}\r\n\r\n/* 挂载孩子 */\r\nfunction mountChildren(children: [], container: HTMLElement, anchor?: Text) {\r\n    children.forEach(child => {\r\n        patch(null, child, container, anchor!)\r\n    })\r\n}\r\n\r\nexport { mountElement, mountTextNode, mountChildren }","import { vNode } from './utils'\r\nimport { patchElement, patchChildren } from './patch'\r\nimport { mountElement, mountTextNode, mountChildren } from './mount'\r\n\r\n// TODO 处理组件\r\n/* 处理组件 */\r\nfunction processComponent(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) { }\r\n\r\n/* 处理容器 */\r\nfunction processFragment(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    const fragmentStartAnchor = n2.elm = n1 ? n1!.elm : document.createTextNode('')\r\n    const fragmentEndAnchor = n2.anchor = n1 ? n1!.anchor : document.createTextNode('')\r\n\r\n    if (n1) {\r\n        patchChildren(n1, n2, container, fragmentEndAnchor as Text)\r\n    } else {\r\n        container.insertBefore(fragmentStartAnchor as Text, anchor as Text)\r\n        container.insertBefore(fragmentEndAnchor as Text, anchor as Text)\r\n        mountChildren(n2.children as [], container, fragmentEndAnchor as Text)\r\n    }\r\n}\r\n\r\n/* 处理文本 */\r\nfunction processText(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    if (n1) {\r\n        if (n1.elm?.textContent !== n2.children) (n1 as any).elm.textContent = n2.children\r\n        n2.elm = n1.elm\r\n    } else {\r\n        mountTextNode(n2, container, anchor)\r\n    }\r\n}\r\n\r\n/* 处理元素 */\r\nfunction processElement(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    if (n1) {\r\n        patchElement(n1, n2)\r\n    } else {\r\n        mountElement(n2, container, anchor)\r\n    }\r\n}\r\n\r\nexport { processComponent, processFragment, processText, processElement } ","import { vNode, isSameVNode, ShapeFlags, domPropsRE, isChildrenKey, getSequence } from \"./utils\"\r\nimport { processComponent, processFragment, processText, processElement } from './process'\r\nimport { unmount, unmountChildren } from './unmount'\r\nimport { mountChildren } from './mount'\r\n\r\nfunction patch(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    if (n1 && !isSameVNode(n1, n2)) {\r\n        /* n1被卸载后，n2将会创建，因此anchor至关重要。需要将它设置为n1的下一个兄弟节点 */\r\n        (anchor as any) = (n1.anchor || n1.elm)!.nextSibling\r\n        unmount(n1)\r\n        n1 = null\r\n    }\r\n\r\n    const { shapeFlag } = n2\r\n    /* 判断 n2 是否是组件 */\r\n    if (shapeFlag & ShapeFlags.COMPONENT) processComponent(n1, n2, container, anchor)\r\n    /* 判断 n2 是否是文本 */\r\n    if (shapeFlag & ShapeFlags.TEXT) processText(n1, n2, container, anchor)\r\n    /* 判断 n2 是否是元素 */\r\n    if (shapeFlag & ShapeFlags.FRAGMENT) processFragment(n1, n2, container, anchor)\r\n    /* 判断 n2 是否是容器 */\r\n    if (shapeFlag & ShapeFlags.ELEMENT) processElement(n1, n2, container, anchor)\r\n}\r\n\r\n/* 更新元素 */\r\nfunction patchElement(n1: vNode | null, n2: vNode) {\r\n    n2.elm = n1!.elm\r\n    patchProps(n1!.props as object, n2.props as object, n2.elm as HTMLElement)\r\n    patchChildren(n1, n2, n2.elm as HTMLElement)\r\n}\r\n\r\n/* 更新属性 */\r\nfunction patchProps(oldProps: object | null, newProps: object | null, container: HTMLElement) {\r\n    if (oldProps === newProps) return\r\n    oldProps = oldProps || {}\r\n    newProps = newProps || {}\r\n    for (const key in newProps) {\r\n        if (key === 'key') continue\r\n        const prev = (oldProps as any)[key]\r\n        const next = (newProps as any)[key]\r\n        if (prev !== next) {\r\n            patchDomProp(container, key, prev, next)\r\n        }\r\n    }\r\n    for (const key in oldProps) {\r\n        if (key !== 'key' && !(key in newProps)) {\r\n            patchDomProp(container, key, (oldProps as any)[key], null)\r\n        }\r\n    }\r\n}\r\n\r\n/* 更新 DOM 属性 */\r\nfunction patchDomProp(el: HTMLElement, key: string, prev: string | object, next: string | object | null) {\r\n    switch (key) {\r\n        case 'class':\r\n            // 暂时认为class就是字符串\r\n            // next可能为null，会变成'null'，因此要设成''\r\n            el.className = next as string || ''\r\n            break\r\n        case 'style':\r\n            // style为对象\r\n            if (!next) {\r\n                el.removeAttribute('style')\r\n            } else {\r\n                for (const styleName in next as object) {\r\n                    (el.style as any)[styleName] = (next as any)[styleName]\r\n                }\r\n                if (prev) {\r\n                    for (const styleName in prev as object) {\r\n                        if ((next as any)[styleName] == null) {\r\n                            (el.style as any)[styleName] = ''\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            break\r\n        default:\r\n            if (/^on[^a-z]/.test(key)) {\r\n                // 事件\r\n                if (prev !== next) {\r\n                    const eventName = key.slice(2).toLowerCase()\r\n                    if (prev) {\r\n                        (el.removeEventListener as any)(eventName, prev)\r\n                    }\r\n                    if (next) {\r\n                        (el.addEventListener as any)(eventName, next)\r\n                    }\r\n                }\r\n            } else if (domPropsRE.test(key)) {\r\n                if (next === '' && typeof (el as any)[key] === 'boolean') {\r\n                    (next as any) = true\r\n                }\r\n                (el as any)[key] = next\r\n            } else {\r\n                // 例如自定义属性{custom: ''}，应该用setAttribute设置为<input custom />\r\n                // 而{custom: null}，应用removeAttribute设置为<input />\r\n                if (next == null || next as any === false) {\r\n                    el.removeAttribute(key)\r\n                } else {\r\n                    el.setAttribute(key, (next as any))\r\n                }\r\n            }\r\n            break\r\n    }\r\n}\r\n\r\n/* 更新孩子 */\r\nfunction patchChildren(n1: vNode | null, n2: vNode, container: HTMLElement, anchor?: Text) {\r\n    const { shapeFlag: prevShapeFlag, children: c1 } = n1!\r\n    const { shapeFlag, children: c2 } = n2\r\n\r\n    /* 新 vNode 孩子是 文本 */\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n        /* 旧 vNode 孩子是 数组  卸载孩子*/\r\n        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1 as [])\r\n        /* 如果 新旧孩子文本内容不一致 文本内容设置为 新孩子    PS：旧 vNode 孩子是 数组 testContent 是 null */\r\n        if (c2 !== c1) container.textContent = c2 as string | null\r\n\r\n        /* 新 vNode 孩子是 数组 */\r\n    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        /* 旧 vNode 孩子是 数组*/\r\n        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n            /* 判断是否有key 调用不同的 diff 算法 */\r\n            if (isChildrenKey(c1 as [], c2 as [])) {\r\n                /* 有 key 时 */\r\n                patchKeyedChildren(c1 as [], c2 as [], container, anchor)\r\n            } else {\r\n                /* 无 key 时 */\r\n                patchUnKeyedChildren(c1 as [], c2 as [], container, anchor)\r\n            }\r\n        } else {\r\n            /* 旧 vNode 孩子是 文本 或 null */\r\n            container.textContent = null\r\n            mountChildren(c2 as [], container, anchor)\r\n        }\r\n\r\n        /* 新 vNode 孩子是 null */\r\n    } else {\r\n        /* 旧 vNode 孩子是 文本 */\r\n        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) container.textContent = null\r\n        /* 旧 vNode 孩子是 数组 */\r\n        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) unmountChildren(c1 as [])\r\n    }\r\n}\r\n\r\n/* 有 key 时 使用的 diff 算法 */\r\nfunction patchKeyedChildren(c1: [], c2: [], container: HTMLElement, anchor?: Text) {\r\n    let start = 0, e1 = c1.length - 1, e2 = c2.length - 1\r\n    /* 1. 从左向右对比 */\r\n    while (start <= e1 && start <= e2 && (c1[start] as any).key === (c2[start] as any).key) {\r\n        patch(c1[start], c2[start], container, anchor)\r\n        start++\r\n    }\r\n    /* 2. 从右向左对比 */\r\n    while (start <= e1 && start <= e2 && (c1 as any)[e1].key === (c2 as any)[e2].key) {\r\n        patch((c1 as any)[e1], (c2 as any)[e2], container, anchor)\r\n        e1--\r\n        e2--\r\n    }\r\n    /* 3.1 比对后 旧孩子 已无元素 */\r\n    if (start > e1) {\r\n        const nextPos = e2 + 1\r\n        const curAnchor = (c2[nextPos] && (c2[nextPos] as any).elm) || anchor\r\n        for (let i = start; i <= e2; i++) {\r\n            patch(null, c2[i], container, curAnchor)\r\n        }\r\n    }\r\n    /* 3.2 对比后 新孩子 已无元素 */\r\n    if (start > e2) {\r\n        for (let i = start; i <= e1; i++) {\r\n            unmount(c1[i])\r\n        }\r\n    }\r\n    /* 4. 对比后 新旧孩子 都还有元素 采用传统diff算法，但不真的添加和移动，只做标记和删除 */\r\n    if (start <= e1 && start <= e2) {\r\n        /* 记录旧孩子 查询使用 */\r\n        const map = new Map()\r\n        for (let i = start; i <= e1; i++) {\r\n            map.set((c1[i] as any).key, { prev: c1[i], index: i })\r\n        }\r\n        /* 旧孩子中上一个对比元素位置下标 */\r\n        let maxNewIndexSoFar = 0\r\n        /* 是否移动 开关 */\r\n        let move = false\r\n        /* 旧孩子中没有没有新孩子节点的下标 给未开启 move 使用 */\r\n        const toMounted = []\r\n        /* 初始化 sources 下标 数组 */\r\n        const sources = new Array(e2 - start + 1).fill(-1)\r\n        /* 查找新节点在旧节点的位置 并且 做标记 和 删除 map 中找到的元素 */\r\n        for (let i = 0; i < e2 - start + 1; i++) {\r\n            const nextPos: any = c2[i + start]\r\n            /* 判断 旧孩子 中是否有 新孩子的key */\r\n            if (map.has(nextPos.key)) {\r\n                const { prev, index } = map.get(nextPos.key);\r\n                /* 进行对比 */\r\n                patch(prev, nextPos, container, anchor)\r\n                /* 判断 当前位置是否需要移动  */\r\n                if (index < maxNewIndexSoFar) {\r\n                    move = true\r\n                } else {\r\n                    maxNewIndexSoFar = index\r\n                }\r\n                /* 设置 新旧孩子节点 下标对应关系 */\r\n                sources[i] = index\r\n                /* 删除 map 中对应的 key 值 */\r\n                map.delete(nextPos.key)\r\n            } else {\r\n                /* 旧孩子中未找到新孩子节点的下标存入 toMounted */\r\n                toMounted.push(i + start)\r\n            }\r\n        }\r\n        /* 删除 旧孩子 剩余元素 */\r\n        map.forEach(({ prev }) => {\r\n            unmount(prev)\r\n        })\r\n        /* 5. 移动开关开启时 移动元素操作 采用新的最长上升子序列算法 */\r\n        if (move) {\r\n            /* 最长上升子序列 下标数组 */\r\n            const sequence: any = getSequence(sources as any)\r\n            /* 数组最长下标 */\r\n            let length = sequence.length - 1\r\n            for (let i = sources.length - 1; i >= 0; i--) {\r\n                /* 下标符合 不做移动 */\r\n                if (i === sequence[length]) {\r\n                    length--\r\n                } else {\r\n                    const pos = i + start\r\n                    const nextPos = pos + 1;\r\n                    const curAnchor = (c2[nextPos] && (c2[nextPos] as any).elm) || anchor\r\n                    if (sources[i] === -1) {\r\n                        /* 旧孩子没有此节点 进行挂载 */\r\n                        patch(null, c2[pos], container, curAnchor)\r\n                    } else {\r\n                        /* 移动操作 */\r\n                        container.insertBefore((c2[pos] as any).elm, curAnchor)\r\n                    }\r\n                }\r\n            }\r\n            /* 6. 未开启 move 还有元素需要添加 情况 */\r\n        } else if (toMounted.length) {\r\n            for (let i = toMounted.length - 1; i >= 0; i++) {\r\n                const pos = toMounted[i]\r\n                const nextPos = pos + 1;\r\n                const curAnchor = (c2[nextPos] && (c2[nextPos] as any).elm) || anchor\r\n                patch(null, c2[pos], container, curAnchor)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/* 无 key 时 使用的 diff 算法 */\r\nfunction patchUnKeyedChildren(c1: [], c2: [], container: HTMLElement, anchor?: Text) {\r\n    const oldLength = c1.length\r\n    const newLength = c2.length\r\n    /* 选取最短的子数组 */\r\n    const commonLength = Math.min(oldLength, newLength)\r\n    /* 对比共同长度的子节点 */\r\n    for (let i = 0; i < commonLength; i++) {\r\n        patch(c1[i], c2[i], container, anchor)\r\n    }\r\n    /* 新孩子 多于 旧孩子 剩下部分 挂载孩子 */\r\n    if (newLength > oldLength) mountChildren(c2.slice(commonLength) as [], container, anchor)\r\n    /* 旧孩子 多于 新孩子 剩下部分 卸载孩子 */\r\n    if (newLength < oldLength) unmountChildren(c1.slice(commonLength) as [])\r\n\r\n}\r\n\r\nexport { patch, patchElement, patchProps, patchChildren }","import { vNode, ShapeFlags } from './utils'\r\n\r\n/* 卸载 vNode */\r\nfunction unmount(vNode: vNode) {\r\n    const { shapeFlag } = vNode\r\n    if (shapeFlag & ShapeFlags.COMPONENT) {\r\n        unmountComponent(vNode)\r\n    } else if (shapeFlag & ShapeFlags.FRAGMENT) {\r\n        unmountFragment(vNode)\r\n    } else {\r\n        unmountElementOrText(vNode)\r\n    }\r\n}\r\n\r\n// TODO 卸载组件\r\n/* 卸载组件 */\r\nfunction unmountComponent(vNode: vNode) { }\r\n\r\n/* 卸载容器 */\r\nfunction unmountFragment(vNode: vNode) {\r\n    let { elm: cur, anchor: end } = vNode\r\n    const parentNode = cur!.parentNode\r\n    while (cur !== end) {\r\n        const next = cur!.nextSibling\r\n        parentNode!.removeChild(cur!);\r\n        (cur as any) = next\r\n    }\r\n    parentNode!.removeChild(end!)\r\n}\r\n\r\n/* 卸载元素或文本 */\r\nfunction unmountElementOrText(vNode: vNode) {\r\n    const { elm } = vNode\r\n    elm!.parentNode!.removeChild(elm as HTMLElement | Text)\r\n}\r\n\r\n/* 卸载孩子 */\r\nfunction unmountChildren(children: []) {\r\n    children.forEach(child => {\r\n        unmount(child)\r\n    })\r\n}\r\n\r\nexport { unmount, unmountChildren }","import { vNode, isString, isNumber, isArray, ShapeFlags, vNodeType } from './utils'\r\n\r\nfunction h(type: string | Symbol | object, props: object | null, children: string | number | [] | null): vNode {\r\n    let shapeFlag: number = vNodeType(type)\r\n\r\n    /* 判断 孩子 是否是 字符串 或者 数字 */\r\n    if (isString(children) || isNumber(children)) {\r\n        /* 用位或运算整合 */\r\n        shapeFlag |= ShapeFlags.TEXT_CHILDREN\r\n        children = children!.toString()\r\n    }\r\n\r\n    /* 判断 孩子 是否是 数组 */\r\n    if (isArray(children)) {\r\n        /* 用位或运算整合 */\r\n        shapeFlag |= ShapeFlags.ARRAY_CHILDREN\r\n    }\r\n\r\n    return { type, props, children, shapeFlag, elm: null, anchor: null, key: props && (props as any).key }\r\n}\r\n\r\nexport { h }","import { vNode } from './utils'\r\nimport { patch } from './patch'\r\nimport { unmount } from './unmount'\r\n\r\n/* 渲染函数 */\r\nfunction render(vNode: vNode | null, container: HTMLElement) {\r\n    const pervVNode = (container as any)._vNode\r\n    /*  判断是否传入新的vNode */\r\n    if (vNode) {\r\n        /* 进行 diff 算法 */\r\n        patch(pervVNode, vNode, container)\r\n    } else {\r\n        /* 没有传入新的 vNode 且有旧的 vNode 卸载旧 vNode */\r\n        if (pervVNode) unmount(pervVNode)\r\n    }\r\n    (container as any)._vNode = vNode\r\n}\r\n\r\nexport { render }","import { isRef } from './utils'\r\nimport { effect } from './effect'\r\n\r\nfunction watch(getter: any, func: Function): Function {\r\n    let _value = isRef(getter) ? getter.value : getter()\r\n\r\n    let effectFn: any = effect(() => isRef(getter) ? getter.value : getter(), {\r\n        scheduler: (effect: any, value: any) => {\r\n            func(value, _value)\r\n            _value = value\r\n        }\r\n    })\r\n    const deps = effectFn.deps\r\n    return function () {\r\n        deps.delete(effectFn)\r\n        effectFn = null\r\n        _value = null\r\n    }\r\n}\r\n\r\nexport { watch }","import { effect } from './effect'\r\n\r\n/* 返回一个函数 调用 停止监听 */\r\nfunction watchEffect(func: Function): Function {\r\n    let effectFn: any = effect(func)\r\n    const deps = effectFn.deps\r\n    return function () {\r\n        deps.delete(effectFn)\r\n        effectFn = null\r\n    }\r\n}\r\n\r\nexport { watchEffect }"],"names":["IS_REACTIVE","RAW","isObject","target","isReactive","isRef","value","hasChanged","oldValue","newValue","Number","isNaN","effectStack","activeEffect","effect","func","options","effectFn","push","pop","length","lazy","scheduler","targetMap","WeakMap","track","key","depsMap","get","set","Map","deps","Set","add","trigger","forEach","reactiveMap","reactive","has","raw","proxy","Proxy","receiver","result","Reflect","oldLength","Array","isArray","createReactiveObject","refImpl","constructor","__isRef","__rawValue","_value","convert","this","ComputedRefImpl","getter","setter","_setter","undefined","_dirty","ShapeFlags","Text","Symbol","Fragment","isString","domPropsRE","mountChildren","children","container","anchor","child","patch","processText","n1","n2","elm","textContent","vNode","textNode","document","createTextNode","insertBefore","mountTextNode","processElement","patchProps","props","patchChildren","patchElement","type","shapeFlag","el","createElement","mountElement","unmount","cur","end","parentNode","next","nextSibling","removeChild","unmountFragment","unmountElementOrText","unmountChildren","isSameVNode","fragmentStartAnchor","fragmentEndAnchor","processFragment","oldProps","newProps","prev","patchDomProp","className","styleName","style","removeAttribute","test","eventName","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","prevShapeFlag","c1","c2","c1True","c2True","c","isChildrenKey","start","e1","e2","nextPos","curAnchor","i","map","index","maxNewIndexSoFar","move","toMounted","sources","fill","delete","_ref","sequence","numberArray","position","l","r","mid","getSequence","pos","patchKeyedChildren","newLength","commonLength","Math","min","patchUnKeyedChildren","getterOrOptions","console","warn","vNodeType","toString","pervVNode","_vNode","ref"],"mappings":"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"}