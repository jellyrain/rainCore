{"version":3,"file":"rainCore.min.js","sources":["../src/reactivity/utils.ts","../src/reactivity/effect.ts","../src/reactivity/reactive.ts","../src/reactivity/ref.ts","../src/reactivity/computed.ts","../src/reactivity/watch.ts","../src/reactivity/watchEffect.ts"],"sourcesContent":["/* reactive 响应式标识 */\r\nexport const IS_REACTIVE: string = '__isReactive'\r\n/* reactive 响应式标识 */\r\nexport const IS_REF: string = '__isRef'\r\n/* 代理前对象标识 */\r\nexport const RAW: string = '__raw'\r\n\r\n/* 判断是否是对象 */\r\nexport function isObject(target: any) {\r\n    return typeof target === 'object' && target != null\r\n}\r\n\r\n/* 判断是否是数组 */\r\nexport function isArray(target: any) {\r\n    return Array.isArray(target)\r\n}\r\n\r\n/* 判断是否是函数 */\r\nexport function isFunction(target: any) {\r\n    return typeof target === 'function' && target != null\r\n}\r\n\r\n/* 判断是否是 reactive 响应式对象 */\r\nexport function isReactive(target: any) {\r\n    return !!(target && target[IS_REACTIVE])\r\n\r\n}\r\n\r\n/* 判断是否是 ref 响应式对象 */\r\nexport function isRef(value: any) {\r\n    return !!(value && value[IS_REF])\r\n}\r\n\r\n/* 判断两个值是否一致 */\r\nexport function hasChanged(oldValue: any, newValue: any) {\r\n    return oldValue !== newValue && !(Number.isNaN(oldValue) || Number.isNaN(newValue))\r\n}","const effectStack: any = []\r\n/* 暴露依赖 */\r\nlet activeEffect: any\r\n\r\nfunction effect(func: Function, options: any = {}): Function {\r\n    const effectFn = () => {\r\n        try {\r\n            effectStack.push(effectFn)\r\n            activeEffect = effectFn\r\n            return func()\r\n        } finally {\r\n            effectStack.pop()\r\n            activeEffect = effectStack[effectStack.length - 1]\r\n        }\r\n    }\r\n    /* 是否先执行一次 */\r\n    if (!options.lazy) effectFn()\r\n\r\n    effectFn.scheduler = options.scheduler\r\n\r\n    return effectFn\r\n}\r\n\r\n/* 收集依赖 */\r\nconst targetMap: WeakMap<object, any> = new WeakMap()\r\n\r\nfunction track(target: any, key: string | symbol): void {\r\n    /* 是否有依赖需要收集 没有直接发返回 */\r\n    if (!activeEffect) return\r\n    /* \r\n        查找是否有此响应式数据对应的依赖组 \r\n        如果没有为该数据创建 Map \r\n    */\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) targetMap.set(target, (depsMap = new Map()))\r\n    /* \r\n        查找是否有此响应式数据内数据的依赖组 \r\n        如果没有为该数据创建 Set \r\n    */\r\n    let deps = depsMap.get(key)\r\n    if (!deps) depsMap.set(key, (deps = new Set()))\r\n    /* 把用到此数据的依赖挂载到 effectFn 上 提供删除 */\r\n    activeEffect.deps = deps\r\n    /* 添加依赖 */\r\n    deps.add(activeEffect)\r\n}\r\n\r\n/* 触发依赖 */\r\nfunction trigger(target: any, key: string | symbol, value: any): void {\r\n    const depsMap = targetMap.get(target)\r\n    /* \r\n        查找是否有此响应式数据对应的依赖组 \r\n        没有就直接返回\r\n    */\r\n    if (!depsMap) return\r\n    /* \r\n       查找是否有此响应式数据内数据的依赖组 \r\n       没有就直接返回\r\n    */\r\n    const deps = depsMap.get(key)\r\n    if (!deps) return\r\n    /* 触发依赖 */\r\n    deps.forEach((effect: { (): any; scheduler: (effect: any, value: any) => any }) => {\r\n        /* 有调度 scheduler 优先触发 scheduler */\r\n        effect.scheduler ? effect.scheduler(effect, value) : effect()\r\n    })\r\n}\r\n\r\nexport { effect, track, trigger, targetMap }","import { IS_REACTIVE, RAW, isObject, isArray, isReactive, hasChanged } from './utils'\r\nimport { track, trigger } from './effect'\r\n\r\n/* 保存响应式对象 */\r\nconst reactiveMap = new WeakMap()\r\n\r\nfunction reactive(target: any) {\r\n    /* 如果不是对象直接返回 */\r\n    if (!isObject(target)) return target\r\n    /* 是否已经是响应式对象 如果是直接返回 */\r\n    if (isReactive(target)) return target\r\n    /* 如果对象已经做过响应式 就直接返沪响应式对象 */\r\n    if (reactiveMap.has(target)) return reactiveMap.get(target)\r\n    /* 创建响应式对象 */\r\n    return createReactiveObject(target)\r\n}\r\n\r\n/* 提供一个响应式对象，返回原始对象 */\r\nfunction toRaw(target: any) {\r\n    if (isReactive(target)) return target[RAW]\r\n}\r\n\r\nfunction createReactiveObject(target: any) {\r\n    const raw = target\r\n    const proxy: any = new Proxy(target, {\r\n        get(target, key, receiver) {\r\n            /* 判断是否是响应式对象 */\r\n            if (key === IS_REACTIVE) return true\r\n            /* 获取原对象 */\r\n            if (key === RAW) return raw\r\n\r\n            const result = Reflect.get(target, key, receiver)\r\n            /* 收集依赖 */\r\n            track(target, key)\r\n            /* 返回值 */\r\n            return isObject(result) ? reactive(result) : result\r\n        },\r\n        set(target, key, value, receiver) {\r\n            /* 获取旧值 */\r\n            const oldValue = target[key]\r\n            const oldLength = target.length\r\n\r\n            const result = Reflect.set(target, key, value, receiver)\r\n            /* 判断新值和旧值是否不一样 */\r\n            if (hasChanged(oldValue, value)) {\r\n                /* 触发依赖 */\r\n                trigger(target, key, value)\r\n                /* 如果是数组 判断是否依赖长度 是 判断是否改变 改变触发依赖 */\r\n                if (isArray(target) && target.length !== oldLength) trigger(target, 'length')\r\n            }\r\n            return result\r\n        }\r\n    })\r\n    /* 添加记录 */\r\n    reactiveMap.set(target, proxy)\r\n    return proxy\r\n}\r\n\r\nexport { reactive, toRaw }","import { isObject, isRef, hasChanged } from './utils'\r\nimport { reactive } from './reactive'\r\nimport { track, trigger } from './effect'\r\n\r\nfunction ref(value: any) {\r\n    /* 是否已经是响应式对象 如果是直接返回 */\r\n    if (isRef(value)) return value\r\n    /* 创建响应式对象 */\r\n    return new refImpl(value)\r\n}\r\n\r\nclass refImpl {\r\n    private __rawValue: any\r\n    private __isRef: boolean\r\n    private _value: any\r\n    /* \r\n        都是基础类型  __rawValue 和 _value 相等\r\n        如果是对象 \r\n            __rawValue：原始对象\r\n            _value：响应式对象\r\n    */\r\n    constructor(value: any) {\r\n        this.__isRef = true\r\n        this.__rawValue = value\r\n        this._value = convert(value)\r\n    }\r\n\r\n    get value() {\r\n        /* 收集依赖 */\r\n        track(this, 'value')\r\n        /* 返回值 */\r\n        return this._value\r\n    }\r\n\r\n    set value(value) {\r\n        if (hasChanged(this._value, value)) {\r\n            /* 更新数据 */\r\n            this._value = convert(value)\r\n            this.__rawValue = value\r\n            /* 触发依赖 */\r\n            trigger(this, 'value', value)\r\n        }\r\n    }\r\n}\r\n\r\nfunction convert(value: any) {\r\n    return isObject(value) ? reactive(value) : value\r\n}\r\n\r\n/* 自动判断是否是 ref 并且获取值 不是 旧返回参数 */\r\nfunction unRef(ref: any) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\n\r\nexport { ref, unRef }","import { track, trigger, effect } from './effect'\r\nimport { isFunction } from './utils'\r\n\r\nfunction computed(getterOrOptions: any): ComputedRefImpl {\r\n    let getter, setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions\r\n        setter = () => {\r\n            console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n    } else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter)\r\n}\r\n\r\nclass ComputedRefImpl {\r\n    private _setter: Function\r\n    private _value: any\r\n    private _dirty: boolean\r\n    private effect: any\r\n    constructor(getter: Function, setter: Function) {\r\n        this._setter = setter\r\n        /* 缓存结果 */\r\n        this._value = undefined\r\n        /* 判断依赖值是否改变 */\r\n        this._dirty = true\r\n        /* 监听依赖变化 */\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true\r\n                    /* 触发依赖 */\r\n                    trigger(this, 'value', this._value)\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect()\r\n            this._dirty = false\r\n            /* 收集依赖 */\r\n            track(this, 'value')\r\n        }\r\n        return this._value\r\n    }\r\n\r\n    set value(value) {\r\n        this._setter(value)\r\n    }\r\n}\r\n\r\nexport { computed }","import { isRef } from './utils'\r\nimport { effect } from './effect'\r\n\r\nfunction watch(getter: any, func: Function): Function {\r\n    let _value = isRef(getter) ? getter.value : getter()\r\n\r\n    let effectFn: any = effect(() => isRef(getter) ? getter.value : getter(), {\r\n        scheduler: (effect: any, value: any) => {\r\n            func(value, _value)\r\n            _value = value\r\n        }\r\n    })\r\n    const deps = effectFn.deps\r\n    return function () {\r\n        deps.delete(effectFn)\r\n        effectFn = null\r\n        _value = null\r\n    }\r\n}\r\n\r\nexport { watch }","import { effect } from './effect'\r\n\r\n/* 返回一个函数 调用 停止监听 */\r\nfunction watchEffect(func: Function): Function {\r\n    let effectFn: any = effect(func)\r\n    const deps = effectFn.deps\r\n    return function () {\r\n        deps.delete(effectFn)\r\n        effectFn = null\r\n    }\r\n}\r\n\r\nexport { watchEffect }"],"names":["IS_REACTIVE","RAW","isObject","target","isReactive","isRef","value","hasChanged","oldValue","newValue","Number","isNaN","effectStack","activeEffect","effect","func","options","effectFn","push","pop","length","lazy","scheduler","targetMap","WeakMap","track","key","depsMap","get","set","Map","deps","Set","add","trigger","forEach","reactiveMap","reactive","has","raw","proxy","Proxy","receiver","result","Reflect","oldLength","Array","isArray","createReactiveObject","refImpl","constructor","__isRef","__rawValue","_value","convert","this","ComputedRefImpl","getter","setter","_setter","undefined","_dirty","getterOrOptions","console","warn","ref","delete"],"mappings":"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"}